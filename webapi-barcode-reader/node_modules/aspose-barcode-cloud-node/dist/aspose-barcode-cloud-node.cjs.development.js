'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var http = _interopDefault(require('https'));

class HttpClient {
  requestAsync(options) {
    //return this.doWithRequest(options);
    return this.doWithHttp(options);
  }
  doWithHttp(options) {
    const url = options.qs ? new URL(`?${new URLSearchParams(options.qs).toString()}`, options.uri) : new URL(options.uri);
    const requestBody = this.buildRequestBody(options);
    const requestOptions = {
      method: options.method,
      headers: options.headers
    };
    const responseEncoding = options.encoding === null ? null : options.encoding || 'utf-8';
    return this.doHttpRequest(url, requestBody, requestOptions, responseEncoding);
  }
  buildRequestBody(options) {
    let requestBody = options.body;
    if (options.form) {
      // Override requestBody for form with form content
      requestBody = new URLSearchParams(options.form).toString();
      options.headers = Object.assign({
        'Content-Type': 'application/x-www-form-urlencoded'
      }, options.headers);
    }
    if (options.json) {
      // Override requestBody with JSON value
      requestBody = JSON.stringify(options.body);
      options.headers = Object.assign({
        'Content-Type': 'application/json'
      }, options.headers);
    }
    return requestBody;
  }
  doHttpRequest(url, requestBody, requestOptions, responseEncoding) {
    return new Promise((resolve, reject) => {
      const req = http.request(url, requestOptions, res => {
        if (responseEncoding) {
          // encoding = null for binary responses
          res.setEncoding(responseEncoding);
        }
        const chunks = [];
        res.on('data', chunk => {
          chunks.push(chunk);
        });
        res.on('end', () => {
          const respBody = responseEncoding ? chunks.join('') : Buffer.concat(chunks);
          const response = {
            statusCode: res.statusCode,
            statusMessage: res.statusMessage,
            headers: res.headers,
            body: respBody
          };
          if (response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({
              response: response,
              body: respBody
            });
          } else {
            reject({
              response: response,
              error: new Error(`Error on '${url}': ${res.statusCode} ${res.statusMessage}`)
            });
          }
        });
      });
      req.on('error', error => {
        reject({
          response: null,
          error: error
        });
      });
      if (requestBody) {
        req.write(requestBody);
      }
      req.end();
    });
  }
}

/*
* MIT License

* Copyright (c) 2023 Aspose Pty Ltd

* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:

* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/
class ApiError {
  static getAttributeTypeMap() {
    return ApiError.attributeTypeMap;
  }
}
ApiError.attributeTypeMap = [{
  name: 'code',
  baseName: 'Code',
  type: 'string'
}, {
  name: 'message',
  baseName: 'Message',
  type: 'string'
}, {
  name: 'description',
  baseName: 'Description',
  type: 'string'
}, {
  name: 'dateTime',
  baseName: 'DateTime',
  type: 'Date'
}, {
  name: 'innerError',
  baseName: 'InnerError',
  type: 'ApiError'
}];
class ApiErrorResponse {
  static getAttributeTypeMap() {
    return ApiErrorResponse.attributeTypeMap;
  }
}
ApiErrorResponse.attributeTypeMap = [{
  name: 'requestId',
  baseName: 'RequestId',
  type: 'string'
}, {
  name: 'error',
  baseName: 'Error',
  type: 'ApiError'
}];
/**
 * AustralianPost barcode parameters.
 */
class AustralianPostParams {
  static getAttributeTypeMap() {
    return AustralianPostParams.attributeTypeMap;
  }
}
AustralianPostParams.attributeTypeMap = [{
  name: 'encodingTable',
  baseName: 'EncodingTable',
  type: 'CustomerInformationInterpretingType'
}, {
  name: 'shortBarHeight',
  baseName: 'ShortBarHeight',
  type: 'number'
}];
(function (AutoSizeMode) {
  AutoSizeMode["None"] = "None";
  AutoSizeMode["Nearest"] = "Nearest";
  AutoSizeMode["Interpolation"] = "Interpolation";
})(exports.AutoSizeMode || (exports.AutoSizeMode = {}));
(function (AvailableGraphicsUnit) {
  AvailableGraphicsUnit["Pixel"] = "Pixel";
  AvailableGraphicsUnit["Point"] = "Point";
  AvailableGraphicsUnit["Inch"] = "Inch";
  AvailableGraphicsUnit["Millimeter"] = "Millimeter";
})(exports.AvailableGraphicsUnit || (exports.AvailableGraphicsUnit = {}));
/**
 * Aztec parameters.
 */
class AztecParams {
  static getAttributeTypeMap() {
    return AztecParams.attributeTypeMap;
  }
}
AztecParams.attributeTypeMap = [{
  name: 'aspectRatio',
  baseName: 'AspectRatio',
  type: 'number'
}, {
  name: 'errorLevel',
  baseName: 'ErrorLevel',
  type: 'number'
}, {
  name: 'symbolMode',
  baseName: 'SymbolMode',
  type: 'AztecSymbolMode'
}, {
  name: 'textEncoding',
  baseName: 'TextEncoding',
  type: 'string'
}];
(function (AztecSymbolMode) {
  AztecSymbolMode["Auto"] = "Auto";
  AztecSymbolMode["Compact"] = "Compact";
  AztecSymbolMode["FullRange"] = "FullRange";
  AztecSymbolMode["Rune"] = "Rune";
})(exports.AztecSymbolMode || (exports.AztecSymbolMode = {}));
/**
 * Represents information about barcode.
 */
class BarcodeResponse {
  static getAttributeTypeMap() {
    return BarcodeResponse.attributeTypeMap;
  }
}
BarcodeResponse.attributeTypeMap = [{
  name: 'barcodeValue',
  baseName: 'BarcodeValue',
  type: 'string'
}, {
  name: 'type',
  baseName: 'Type',
  type: 'string'
}, {
  name: 'region',
  baseName: 'Region',
  type: 'Array<RegionPoint>'
}, {
  name: 'checksum',
  baseName: 'Checksum',
  type: 'string'
}];
/**
 * Represents information about barcode list.
 */
class BarcodeResponseList {
  static getAttributeTypeMap() {
    return BarcodeResponseList.attributeTypeMap;
  }
}
BarcodeResponseList.attributeTypeMap = [{
  name: 'barcodes',
  baseName: 'Barcodes',
  type: 'Array<BarcodeResponse>'
}];
(function (BorderDashStyle) {
  BorderDashStyle["Solid"] = "Solid";
  BorderDashStyle["Dash"] = "Dash";
  BorderDashStyle["Dot"] = "Dot";
  BorderDashStyle["DashDot"] = "DashDot";
  BorderDashStyle["DashDotDot"] = "DashDotDot";
})(exports.BorderDashStyle || (exports.BorderDashStyle = {}));
/**
 * Caption
 */
class CaptionParams {
  static getAttributeTypeMap() {
    return CaptionParams.attributeTypeMap;
  }
}
CaptionParams.attributeTypeMap = [{
  name: 'text',
  baseName: 'Text',
  type: 'string'
}, {
  name: 'alignment',
  baseName: 'Alignment',
  type: 'TextAlignment'
}, {
  name: 'color',
  baseName: 'Color',
  type: 'string'
}, {
  name: 'visible',
  baseName: 'Visible',
  type: 'boolean'
}, {
  name: 'font',
  baseName: 'Font',
  type: 'FontParams'
}, {
  name: 'padding',
  baseName: 'Padding',
  type: 'Padding'
}, {
  name: 'noWrap',
  baseName: 'NoWrap',
  type: 'boolean'
}];
(function (ChecksumValidation) {
  ChecksumValidation["Default"] = "Default";
  ChecksumValidation["On"] = "On";
  ChecksumValidation["Off"] = "Off";
})(exports.ChecksumValidation || (exports.ChecksumValidation = {}));
(function (CodabarChecksumMode) {
  CodabarChecksumMode["Mod10"] = "Mod10";
  CodabarChecksumMode["Mod16"] = "Mod16";
})(exports.CodabarChecksumMode || (exports.CodabarChecksumMode = {}));
/**
 * Codabar parameters.
 */
class CodabarParams {
  static getAttributeTypeMap() {
    return CodabarParams.attributeTypeMap;
  }
}
CodabarParams.attributeTypeMap = [{
  name: 'checksumMode',
  baseName: 'ChecksumMode',
  type: 'CodabarChecksumMode'
}, {
  name: 'startSymbol',
  baseName: 'StartSymbol',
  type: 'CodabarSymbol'
}, {
  name: 'stopSymbol',
  baseName: 'StopSymbol',
  type: 'CodabarSymbol'
}];
(function (CodabarSymbol) {
  CodabarSymbol["A"] = "A";
  CodabarSymbol["B"] = "B";
  CodabarSymbol["C"] = "C";
  CodabarSymbol["D"] = "D";
})(exports.CodabarSymbol || (exports.CodabarSymbol = {}));
/**
 * Codablock parameters.
 */
class CodablockParams {
  static getAttributeTypeMap() {
    return CodablockParams.attributeTypeMap;
  }
}
CodablockParams.attributeTypeMap = [{
  name: 'aspectRatio',
  baseName: 'AspectRatio',
  type: 'number'
}, {
  name: 'columns',
  baseName: 'Columns',
  type: 'number'
}, {
  name: 'rows',
  baseName: 'Rows',
  type: 'number'
}];
(function (Code128Emulation) {
  Code128Emulation["None"] = "None";
  Code128Emulation["Code903"] = "Code903";
  Code128Emulation["Code904"] = "Code904";
  Code128Emulation["Code905"] = "Code905";
})(exports.Code128Emulation || (exports.Code128Emulation = {}));
(function (Code128EncodeMode) {
  Code128EncodeMode["Auto"] = "Auto";
  Code128EncodeMode["CodeA"] = "CodeA";
  Code128EncodeMode["CodeB"] = "CodeB";
  Code128EncodeMode["CodeAB"] = "CodeAB";
  Code128EncodeMode["CodeC"] = "CodeC";
  Code128EncodeMode["CodeAC"] = "CodeAC";
  Code128EncodeMode["CodeBC"] = "CodeBC";
})(exports.Code128EncodeMode || (exports.Code128EncodeMode = {}));
/**
 * Code128 params.
 */
class Code128Params {
  static getAttributeTypeMap() {
    return Code128Params.attributeTypeMap;
  }
}
Code128Params.attributeTypeMap = [{
  name: 'encodeMode',
  baseName: 'EncodeMode',
  type: 'Code128EncodeMode'
}];
/**
 * Code16K parameters.
 */
class Code16KParams {
  static getAttributeTypeMap() {
    return Code16KParams.attributeTypeMap;
  }
}
Code16KParams.attributeTypeMap = [{
  name: 'aspectRatio',
  baseName: 'AspectRatio',
  type: 'number'
}, {
  name: 'quietZoneLeftCoef',
  baseName: 'QuietZoneLeftCoef',
  type: 'number'
}, {
  name: 'quietZoneRightCoef',
  baseName: 'QuietZoneRightCoef',
  type: 'number'
}];
(function (CodeLocation) {
  CodeLocation["Below"] = "Below";
  CodeLocation["Above"] = "Above";
  CodeLocation["None"] = "None";
})(exports.CodeLocation || (exports.CodeLocation = {}));
/**
 * Coupon parameters. Used for UpcaGs1DatabarCoupon, UpcaGs1Code128Coupon.
 */
class CouponParams {
  static getAttributeTypeMap() {
    return CouponParams.attributeTypeMap;
  }
}
CouponParams.attributeTypeMap = [{
  name: 'supplementSpace',
  baseName: 'SupplementSpace',
  type: 'number'
}];
(function (CustomerInformationInterpretingType) {
  CustomerInformationInterpretingType["CTable"] = "CTable";
  CustomerInformationInterpretingType["NTable"] = "NTable";
  CustomerInformationInterpretingType["Other"] = "Other";
})(exports.CustomerInformationInterpretingType || (exports.CustomerInformationInterpretingType = {}));
/**
 * Databar parameters.
 */
class DataBarParams {
  static getAttributeTypeMap() {
    return DataBarParams.attributeTypeMap;
  }
}
DataBarParams.attributeTypeMap = [{
  name: 'aspectRatio',
  baseName: 'AspectRatio',
  type: 'number'
}, {
  name: 'columns',
  baseName: 'Columns',
  type: 'number'
}, {
  name: 'rows',
  baseName: 'Rows',
  type: 'number'
}, {
  name: 'is2DCompositeComponent',
  baseName: 'Is2DCompositeComponent',
  type: 'boolean'
}, {
  name: 'isAllowOnlyGS1Encoding',
  baseName: 'IsAllowOnlyGS1Encoding',
  type: 'boolean'
}];
(function (DataMatrixEccType) {
  DataMatrixEccType["EccAuto"] = "EccAuto";
  DataMatrixEccType["Ecc000"] = "Ecc000";
  DataMatrixEccType["Ecc050"] = "Ecc050";
  DataMatrixEccType["Ecc080"] = "Ecc080";
  DataMatrixEccType["Ecc100"] = "Ecc100";
  DataMatrixEccType["Ecc140"] = "Ecc140";
  DataMatrixEccType["Ecc200"] = "Ecc200";
})(exports.DataMatrixEccType || (exports.DataMatrixEccType = {}));
(function (DataMatrixEncodeMode) {
  DataMatrixEncodeMode["Auto"] = "Auto";
  DataMatrixEncodeMode["ASCII"] = "ASCII";
  DataMatrixEncodeMode["Full"] = "Full";
  DataMatrixEncodeMode["Custom"] = "Custom";
  DataMatrixEncodeMode["C40"] = "C40";
  DataMatrixEncodeMode["Text"] = "Text";
  DataMatrixEncodeMode["EDIFACT"] = "EDIFACT";
  DataMatrixEncodeMode["ANSIX12"] = "ANSIX12";
  DataMatrixEncodeMode["ExtendedCodetext"] = "ExtendedCodetext";
})(exports.DataMatrixEncodeMode || (exports.DataMatrixEncodeMode = {}));
/**
 * DataMatrix parameters.
 */
class DataMatrixParams {
  static getAttributeTypeMap() {
    return DataMatrixParams.attributeTypeMap;
  }
}
DataMatrixParams.attributeTypeMap = [{
  name: 'aspectRatio',
  baseName: 'AspectRatio',
  type: 'number'
}, {
  name: 'textEncoding',
  baseName: 'TextEncoding',
  type: 'string'
}, {
  name: 'columns',
  baseName: 'Columns',
  type: 'number'
}, {
  name: 'dataMatrixEcc',
  baseName: 'DataMatrixEcc',
  type: 'DataMatrixEccType'
}, {
  name: 'dataMatrixEncodeMode',
  baseName: 'DataMatrixEncodeMode',
  type: 'DataMatrixEncodeMode'
}, {
  name: 'rows',
  baseName: 'Rows',
  type: 'number'
}, {
  name: 'macroCharacters',
  baseName: 'MacroCharacters',
  type: 'MacroCharacter'
}];
(function (DecodeBarcodeType) {
  DecodeBarcodeType["All"] = "all";
  DecodeBarcodeType["AustraliaPost"] = "AustraliaPost";
  DecodeBarcodeType["Aztec"] = "Aztec";
  DecodeBarcodeType["ISBN"] = "ISBN";
  DecodeBarcodeType["Codabar"] = "Codabar";
  DecodeBarcodeType["Code11"] = "Code11";
  DecodeBarcodeType["Code128"] = "Code128";
  DecodeBarcodeType["GS1Code128"] = "GS1Code128";
  DecodeBarcodeType["Code39Extended"] = "Code39Extended";
  DecodeBarcodeType["Code39Standard"] = "Code39Standard";
  DecodeBarcodeType["Code93Extended"] = "Code93Extended";
  DecodeBarcodeType["Code93Standard"] = "Code93Standard";
  DecodeBarcodeType["DataMatrix"] = "DataMatrix";
  DecodeBarcodeType["DeutschePostIdentcode"] = "DeutschePostIdentcode";
  DecodeBarcodeType["DeutschePostLeitcode"] = "DeutschePostLeitcode";
  DecodeBarcodeType["EAN13"] = "EAN13";
  DecodeBarcodeType["EAN14"] = "EAN14";
  DecodeBarcodeType["EAN8"] = "EAN8";
  DecodeBarcodeType["IATA2of5"] = "IATA2of5";
  DecodeBarcodeType["Interleaved2of5"] = "Interleaved2of5";
  DecodeBarcodeType["ISSN"] = "ISSN";
  DecodeBarcodeType["ISMN"] = "ISMN";
  DecodeBarcodeType["ItalianPost25"] = "ItalianPost25";
  DecodeBarcodeType["ITF14"] = "ITF14";
  DecodeBarcodeType["ITF6"] = "ITF6";
  DecodeBarcodeType["MacroPdf417"] = "MacroPdf417";
  DecodeBarcodeType["Matrix2of5"] = "Matrix2of5";
  DecodeBarcodeType["MSI"] = "MSI";
  DecodeBarcodeType["OneCode"] = "OneCode";
  DecodeBarcodeType["OPC"] = "OPC";
  DecodeBarcodeType["PatchCode"] = "PatchCode";
  DecodeBarcodeType["Pdf417"] = "Pdf417";
  DecodeBarcodeType["MicroPdf417"] = "MicroPdf417";
  DecodeBarcodeType["Planet"] = "Planet";
  DecodeBarcodeType["Postnet"] = "Postnet";
  DecodeBarcodeType["PZN"] = "PZN";
  DecodeBarcodeType["QR"] = "QR";
  DecodeBarcodeType["MicroQR"] = "MicroQR";
  DecodeBarcodeType["RM4SCC"] = "RM4SCC";
  DecodeBarcodeType["SCC14"] = "SCC14";
  DecodeBarcodeType["SSCC18"] = "SSCC18";
  DecodeBarcodeType["Standard2of5"] = "Standard2of5";
  DecodeBarcodeType["Supplement"] = "Supplement";
  DecodeBarcodeType["UPCA"] = "UPCA";
  DecodeBarcodeType["UPCE"] = "UPCE";
  DecodeBarcodeType["VIN"] = "VIN";
  DecodeBarcodeType["Pharmacode"] = "Pharmacode";
  DecodeBarcodeType["GS1DataMatrix"] = "GS1DataMatrix";
  DecodeBarcodeType["DatabarOmniDirectional"] = "DatabarOmniDirectional";
  DecodeBarcodeType["DatabarTruncated"] = "DatabarTruncated";
  DecodeBarcodeType["DatabarLimited"] = "DatabarLimited";
  DecodeBarcodeType["DatabarExpanded"] = "DatabarExpanded";
  DecodeBarcodeType["SwissPostParcel"] = "SwissPostParcel";
  DecodeBarcodeType["AustralianPosteParcel"] = "AustralianPosteParcel";
  DecodeBarcodeType["Code16K"] = "Code16K";
  DecodeBarcodeType["DatabarStackedOmniDirectional"] = "DatabarStackedOmniDirectional";
  DecodeBarcodeType["DatabarStacked"] = "DatabarStacked";
  DecodeBarcodeType["DatabarExpandedStacked"] = "DatabarExpandedStacked";
  DecodeBarcodeType["CompactPdf417"] = "CompactPdf417";
  DecodeBarcodeType["GS1QR"] = "GS1QR";
  DecodeBarcodeType["MaxiCode"] = "MaxiCode";
  DecodeBarcodeType["MicrE13B"] = "MicrE13B";
  DecodeBarcodeType["Code32"] = "Code32";
  DecodeBarcodeType["DataLogic2of5"] = "DataLogic2of5";
  DecodeBarcodeType["DotCode"] = "DotCode";
  DecodeBarcodeType["DutchKIX"] = "DutchKIX";
  DecodeBarcodeType["CodablockF"] = "CodablockF";
  DecodeBarcodeType["Mailmark"] = "Mailmark";
  DecodeBarcodeType["GS1DotCode"] = "GS1DotCode";
  DecodeBarcodeType["HIBCCode39LIC"] = "HIBCCode39LIC";
  DecodeBarcodeType["HIBCCode128LIC"] = "HIBCCode128LIC";
  DecodeBarcodeType["HIBCAztecLIC"] = "HIBCAztecLIC";
  DecodeBarcodeType["HIBCDataMatrixLIC"] = "HIBCDataMatrixLIC";
  DecodeBarcodeType["HIBCQRLIC"] = "HIBCQRLIC";
  DecodeBarcodeType["HIBCCode39PAS"] = "HIBCCode39PAS";
  DecodeBarcodeType["HIBCCode128PAS"] = "HIBCCode128PAS";
  DecodeBarcodeType["HIBCAztecPAS"] = "HIBCAztecPAS";
  DecodeBarcodeType["HIBCDataMatrixPAS"] = "HIBCDataMatrixPAS";
  DecodeBarcodeType["HIBCQRPAS"] = "HIBCQRPAS";
})(exports.DecodeBarcodeType || (exports.DecodeBarcodeType = {}));
/**
 * Class for disc space information.
 */
class DiscUsage {
  static getAttributeTypeMap() {
    return DiscUsage.attributeTypeMap;
  }
}
DiscUsage.attributeTypeMap = [{
  name: 'usedSize',
  baseName: 'UsedSize',
  type: 'number'
}, {
  name: 'totalSize',
  baseName: 'TotalSize',
  type: 'number'
}];
(function (DotCodeEncodeMode) {
  DotCodeEncodeMode["Auto"] = "Auto";
  DotCodeEncodeMode["Bytes"] = "Bytes";
  DotCodeEncodeMode["ExtendedCodetext"] = "ExtendedCodetext";
})(exports.DotCodeEncodeMode || (exports.DotCodeEncodeMode = {}));
/**
 * DotCode parameters.
 */
class DotCodeParams {
  static getAttributeTypeMap() {
    return DotCodeParams.attributeTypeMap;
  }
}
DotCodeParams.attributeTypeMap = [{
  name: 'aspectRatio',
  baseName: 'AspectRatio',
  type: 'number'
}, {
  name: 'columns',
  baseName: 'Columns',
  type: 'number'
}, {
  name: 'encodeMode',
  baseName: 'EncodeMode',
  type: 'DotCodeEncodeMode'
}, {
  name: 'eCIEncoding',
  baseName: 'ECIEncoding',
  type: 'ECIEncodings'
}, {
  name: 'isReaderInitialization',
  baseName: 'IsReaderInitialization',
  type: 'boolean'
}, {
  name: 'rows',
  baseName: 'Rows',
  type: 'number'
}];
(function (ECIEncodings) {
  ECIEncodings["NONE"] = "NONE";
  ECIEncodings["ISO88591"] = "ISO_8859_1";
  ECIEncodings["ISO88592"] = "ISO_8859_2";
  ECIEncodings["ISO88593"] = "ISO_8859_3";
  ECIEncodings["ISO88594"] = "ISO_8859_4";
  ECIEncodings["ISO88595"] = "ISO_8859_5";
  ECIEncodings["ISO88596"] = "ISO_8859_6";
  ECIEncodings["ISO88597"] = "ISO_8859_7";
  ECIEncodings["ISO88598"] = "ISO_8859_8";
  ECIEncodings["ISO88599"] = "ISO_8859_9";
  ECIEncodings["ISO885910"] = "ISO_8859_10";
  ECIEncodings["ISO885911"] = "ISO_8859_11";
  ECIEncodings["ISO885913"] = "ISO_8859_13";
  ECIEncodings["ISO885914"] = "ISO_8859_14";
  ECIEncodings["ISO885915"] = "ISO_8859_15";
  ECIEncodings["ISO885916"] = "ISO_8859_16";
  ECIEncodings["ShiftJIS"] = "Shift_JIS";
  ECIEncodings["Win1250"] = "Win1250";
  ECIEncodings["Win1251"] = "Win1251";
  ECIEncodings["Win1252"] = "Win1252";
  ECIEncodings["Win1256"] = "Win1256";
  ECIEncodings["UTF16BE"] = "UTF16BE";
  ECIEncodings["UTF8"] = "UTF8";
  ECIEncodings["USASCII"] = "US_ASCII";
  ECIEncodings["Big5"] = "Big5";
  ECIEncodings["GB18030"] = "GB18030";
  ECIEncodings["EUCKR"] = "EUC_KR";
})(exports.ECIEncodings || (exports.ECIEncodings = {}));
(function (EnableChecksum) {
  EnableChecksum["Default"] = "Default";
  EnableChecksum["Yes"] = "Yes";
  EnableChecksum["No"] = "No";
})(exports.EnableChecksum || (exports.EnableChecksum = {}));
(function (EncodeBarcodeType) {
  EncodeBarcodeType["Codabar"] = "Codabar";
  EncodeBarcodeType["Code11"] = "Code11";
  EncodeBarcodeType["Code39Standard"] = "Code39Standard";
  EncodeBarcodeType["Code39Extended"] = "Code39Extended";
  EncodeBarcodeType["Code93Standard"] = "Code93Standard";
  EncodeBarcodeType["Code93Extended"] = "Code93Extended";
  EncodeBarcodeType["Code128"] = "Code128";
  EncodeBarcodeType["GS1Code128"] = "GS1Code128";
  EncodeBarcodeType["EAN8"] = "EAN8";
  EncodeBarcodeType["EAN13"] = "EAN13";
  EncodeBarcodeType["EAN14"] = "EAN14";
  EncodeBarcodeType["SCC14"] = "SCC14";
  EncodeBarcodeType["SSCC18"] = "SSCC18";
  EncodeBarcodeType["UPCA"] = "UPCA";
  EncodeBarcodeType["UPCE"] = "UPCE";
  EncodeBarcodeType["ISBN"] = "ISBN";
  EncodeBarcodeType["ISSN"] = "ISSN";
  EncodeBarcodeType["ISMN"] = "ISMN";
  EncodeBarcodeType["Standard2of5"] = "Standard2of5";
  EncodeBarcodeType["Interleaved2of5"] = "Interleaved2of5";
  EncodeBarcodeType["Matrix2of5"] = "Matrix2of5";
  EncodeBarcodeType["ItalianPost25"] = "ItalianPost25";
  EncodeBarcodeType["IATA2of5"] = "IATA2of5";
  EncodeBarcodeType["ITF14"] = "ITF14";
  EncodeBarcodeType["ITF6"] = "ITF6";
  EncodeBarcodeType["MSI"] = "MSI";
  EncodeBarcodeType["VIN"] = "VIN";
  EncodeBarcodeType["DeutschePostIdentcode"] = "DeutschePostIdentcode";
  EncodeBarcodeType["DeutschePostLeitcode"] = "DeutschePostLeitcode";
  EncodeBarcodeType["OPC"] = "OPC";
  EncodeBarcodeType["PZN"] = "PZN";
  EncodeBarcodeType["Code16K"] = "Code16K";
  EncodeBarcodeType["Pharmacode"] = "Pharmacode";
  EncodeBarcodeType["DataMatrix"] = "DataMatrix";
  EncodeBarcodeType["QR"] = "QR";
  EncodeBarcodeType["Aztec"] = "Aztec";
  EncodeBarcodeType["Pdf417"] = "Pdf417";
  EncodeBarcodeType["MacroPdf417"] = "MacroPdf417";
  EncodeBarcodeType["AustraliaPost"] = "AustraliaPost";
  EncodeBarcodeType["Postnet"] = "Postnet";
  EncodeBarcodeType["Planet"] = "Planet";
  EncodeBarcodeType["OneCode"] = "OneCode";
  EncodeBarcodeType["RM4SCC"] = "RM4SCC";
  EncodeBarcodeType["DatabarOmniDirectional"] = "DatabarOmniDirectional";
  EncodeBarcodeType["DatabarTruncated"] = "DatabarTruncated";
  EncodeBarcodeType["DatabarLimited"] = "DatabarLimited";
  EncodeBarcodeType["DatabarExpanded"] = "DatabarExpanded";
  EncodeBarcodeType["SingaporePost"] = "SingaporePost";
  EncodeBarcodeType["GS1DataMatrix"] = "GS1DataMatrix";
  EncodeBarcodeType["AustralianPosteParcel"] = "AustralianPosteParcel";
  EncodeBarcodeType["SwissPostParcel"] = "SwissPostParcel";
  EncodeBarcodeType["PatchCode"] = "PatchCode";
  EncodeBarcodeType["DatabarExpandedStacked"] = "DatabarExpandedStacked";
  EncodeBarcodeType["DatabarStacked"] = "DatabarStacked";
  EncodeBarcodeType["DatabarStackedOmniDirectional"] = "DatabarStackedOmniDirectional";
  EncodeBarcodeType["MicroPdf417"] = "MicroPdf417";
  EncodeBarcodeType["GS1QR"] = "GS1QR";
  EncodeBarcodeType["MaxiCode"] = "MaxiCode";
  EncodeBarcodeType["Code32"] = "Code32";
  EncodeBarcodeType["DataLogic2of5"] = "DataLogic2of5";
  EncodeBarcodeType["DotCode"] = "DotCode";
  EncodeBarcodeType["DutchKIX"] = "DutchKIX";
  EncodeBarcodeType["UpcaGs1Code128Coupon"] = "UpcaGs1Code128Coupon";
  EncodeBarcodeType["UpcaGs1DatabarCoupon"] = "UpcaGs1DatabarCoupon";
  EncodeBarcodeType["CodablockF"] = "CodablockF";
  EncodeBarcodeType["GS1CodablockF"] = "GS1CodablockF";
  EncodeBarcodeType["Mailmark"] = "Mailmark";
  EncodeBarcodeType["GS1DotCode"] = "GS1DotCode";
})(exports.EncodeBarcodeType || (exports.EncodeBarcodeType = {}));
/**
 * The error details
 */
class ErrorDetails {
  static getAttributeTypeMap() {
    return ErrorDetails.attributeTypeMap;
  }
}
ErrorDetails.attributeTypeMap = [{
  name: 'requestId',
  baseName: 'RequestId',
  type: 'string'
}, {
  name: 'date',
  baseName: 'Date',
  type: 'Date'
}];
/**
 * File versions FileVersion.
 */
class FileVersions {
  static getAttributeTypeMap() {
    return FileVersions.attributeTypeMap;
  }
}
FileVersions.attributeTypeMap = [{
  name: 'value',
  baseName: 'Value',
  type: 'Array<FileVersion>'
}];
/**
 * Files list
 */
class FilesList {
  static getAttributeTypeMap() {
    return FilesList.attributeTypeMap;
  }
}
FilesList.attributeTypeMap = [{
  name: 'value',
  baseName: 'Value',
  type: 'Array<StorageFile>'
}];
/**
 * File upload result
 */
class FilesUploadResult {
  static getAttributeTypeMap() {
    return FilesUploadResult.attributeTypeMap;
  }
}
FilesUploadResult.attributeTypeMap = [{
  name: 'uploaded',
  baseName: 'Uploaded',
  type: 'Array<string>'
}, {
  name: 'errors',
  baseName: 'Errors',
  type: 'Array<Error>'
}];
(function (FontMode) {
  FontMode["Auto"] = "Auto";
  FontMode["Manual"] = "Manual";
})(exports.FontMode || (exports.FontMode = {}));
/**
 * Font.
 */
class FontParams {
  static getAttributeTypeMap() {
    return FontParams.attributeTypeMap;
  }
}
FontParams.attributeTypeMap = [{
  name: 'family',
  baseName: 'Family',
  type: 'string'
}, {
  name: 'size',
  baseName: 'Size',
  type: 'number'
}, {
  name: 'style',
  baseName: 'Style',
  type: 'FontStyle'
}];
(function (FontStyle) {
  FontStyle["Regular"] = "Regular";
  FontStyle["Bold"] = "Bold";
  FontStyle["Italic"] = "Italic";
  FontStyle["Underline"] = "Underline";
  FontStyle["Strikeout"] = "Strikeout";
})(exports.FontStyle || (exports.FontStyle = {}));
/**
 * Represents extended BarcodeGenerator params.
 */
class GeneratorParams {
  static getAttributeTypeMap() {
    return GeneratorParams.attributeTypeMap;
  }
}
GeneratorParams.attributeTypeMap = [{
  name: 'typeOfBarcode',
  baseName: 'TypeOfBarcode',
  type: 'EncodeBarcodeType'
}, {
  name: 'text',
  baseName: 'Text',
  type: 'string'
}, {
  name: 'twoDDisplayText',
  baseName: 'TwoDDisplayText',
  type: 'string'
}, {
  name: 'textLocation',
  baseName: 'TextLocation',
  type: 'CodeLocation'
}, {
  name: 'textAlignment',
  baseName: 'TextAlignment',
  type: 'TextAlignment'
}, {
  name: 'textColor',
  baseName: 'TextColor',
  type: 'string'
}, {
  name: 'font',
  baseName: 'Font',
  type: 'FontParams'
}, {
  name: 'fontSizeMode',
  baseName: 'FontSizeMode',
  type: 'FontMode'
}, {
  name: 'noWrap',
  baseName: 'NoWrap',
  type: 'boolean'
}, {
  name: 'resolution',
  baseName: 'Resolution',
  type: 'number'
}, {
  name: 'resolutionX',
  baseName: 'ResolutionX',
  type: 'number'
}, {
  name: 'resolutionY',
  baseName: 'ResolutionY',
  type: 'number'
}, {
  name: 'dimensionX',
  baseName: 'DimensionX',
  type: 'number'
}, {
  name: 'textSpace',
  baseName: 'TextSpace',
  type: 'number'
}, {
  name: 'units',
  baseName: 'Units',
  type: 'AvailableGraphicsUnit'
}, {
  name: 'sizeMode',
  baseName: 'SizeMode',
  type: 'AutoSizeMode'
}, {
  name: 'barHeight',
  baseName: 'BarHeight',
  type: 'number'
}, {
  name: 'imageHeight',
  baseName: 'ImageHeight',
  type: 'number'
}, {
  name: 'imageWidth',
  baseName: 'ImageWidth',
  type: 'number'
}, {
  name: 'rotationAngle',
  baseName: 'RotationAngle',
  type: 'number'
}, {
  name: 'padding',
  baseName: 'Padding',
  type: 'Padding'
}, {
  name: 'captionAbove',
  baseName: 'CaptionAbove',
  type: 'CaptionParams'
}, {
  name: 'captionBelow',
  baseName: 'CaptionBelow',
  type: 'CaptionParams'
}, {
  name: 'backColor',
  baseName: 'BackColor',
  type: 'string'
}, {
  name: 'barColor',
  baseName: 'BarColor',
  type: 'string'
}, {
  name: 'borderColor',
  baseName: 'BorderColor',
  type: 'string'
}, {
  name: 'borderWidth',
  baseName: 'BorderWidth',
  type: 'number'
}, {
  name: 'borderDashStyle',
  baseName: 'BorderDashStyle',
  type: 'BorderDashStyle'
}, {
  name: 'borderVisible',
  baseName: 'BorderVisible',
  type: 'boolean'
}, {
  name: 'enableChecksum',
  baseName: 'EnableChecksum',
  type: 'EnableChecksum'
}, {
  name: 'enableEscape',
  baseName: 'EnableEscape',
  type: 'boolean'
}, {
  name: 'filledBars',
  baseName: 'FilledBars',
  type: 'boolean'
}, {
  name: 'alwaysShowChecksum',
  baseName: 'AlwaysShowChecksum',
  type: 'boolean'
}, {
  name: 'wideNarrowRatio',
  baseName: 'WideNarrowRatio',
  type: 'number'
}, {
  name: 'validateText',
  baseName: 'ValidateText',
  type: 'boolean'
}, {
  name: 'supplementData',
  baseName: 'SupplementData',
  type: 'string'
}, {
  name: 'supplementSpace',
  baseName: 'SupplementSpace',
  type: 'number'
}, {
  name: 'barWidthReduction',
  baseName: 'BarWidthReduction',
  type: 'number'
}, {
  name: 'useAntiAlias',
  baseName: 'UseAntiAlias',
  type: 'boolean'
}, {
  name: 'australianPost',
  baseName: 'AustralianPost',
  type: 'AustralianPostParams'
}, {
  name: 'aztec',
  baseName: 'Aztec',
  type: 'AztecParams'
}, {
  name: 'codabar',
  baseName: 'Codabar',
  type: 'CodabarParams'
}, {
  name: 'codablock',
  baseName: 'Codablock',
  type: 'CodablockParams'
}, {
  name: 'code16K',
  baseName: 'Code16K',
  type: 'Code16KParams'
}, {
  name: 'coupon',
  baseName: 'Coupon',
  type: 'CouponParams'
}, {
  name: 'dataBar',
  baseName: 'DataBar',
  type: 'DataBarParams'
}, {
  name: 'dataMatrix',
  baseName: 'DataMatrix',
  type: 'DataMatrixParams'
}, {
  name: 'dotCode',
  baseName: 'DotCode',
  type: 'DotCodeParams'
}, {
  name: 'ITF',
  baseName: 'ITF',
  type: 'ITFParams'
}, {
  name: 'maxiCode',
  baseName: 'MaxiCode',
  type: 'MaxiCodeParams'
}, {
  name: 'pdf417',
  baseName: 'Pdf417',
  type: 'Pdf417Params'
}, {
  name: 'postal',
  baseName: 'Postal',
  type: 'PostalParams'
}, {
  name: 'QR',
  baseName: 'QR',
  type: 'QrParams'
}, {
  name: 'patchCode',
  baseName: 'PatchCode',
  type: 'PatchCodeParams'
}, {
  name: 'code128',
  baseName: 'Code128',
  type: 'Code128Params'
}];
/**
 * Represents list of barcode generators
 */
class GeneratorParamsList {
  static getAttributeTypeMap() {
    return GeneratorParamsList.attributeTypeMap;
  }
}
GeneratorParamsList.attributeTypeMap = [{
  name: 'barcodeBuilders',
  baseName: 'BarcodeBuilders',
  type: 'Array<GeneratorParams>'
}, {
  name: 'xStep',
  baseName: 'XStep',
  type: 'number'
}, {
  name: 'yStep',
  baseName: 'YStep',
  type: 'number'
}];
(function (ITF14BorderType) {
  ITF14BorderType["None"] = "None";
  ITF14BorderType["Frame"] = "Frame";
  ITF14BorderType["Bar"] = "Bar";
  ITF14BorderType["FrameOut"] = "FrameOut";
  ITF14BorderType["BarOut"] = "BarOut";
})(exports.ITF14BorderType || (exports.ITF14BorderType = {}));
/**
 * ITF parameters.
 */
class ITFParams {
  static getAttributeTypeMap() {
    return ITFParams.attributeTypeMap;
  }
}
ITFParams.attributeTypeMap = [{
  name: 'borderThickness',
  baseName: 'BorderThickness',
  type: 'number'
}, {
  name: 'borderType',
  baseName: 'BorderType',
  type: 'ITF14BorderType'
}, {
  name: 'quietZoneCoef',
  baseName: 'QuietZoneCoef',
  type: 'number'
}];
(function (MacroCharacter) {
  MacroCharacter["None"] = "None";
  MacroCharacter["Macro05"] = "Macro05";
  MacroCharacter["Macro06"] = "Macro06";
})(exports.MacroCharacter || (exports.MacroCharacter = {}));
(function (MaxiCodeEncodeMode) {
  MaxiCodeEncodeMode["Auto"] = "Auto";
  MaxiCodeEncodeMode["Bytes"] = "Bytes";
  MaxiCodeEncodeMode["ExtendedCodetext"] = "ExtendedCodetext";
})(exports.MaxiCodeEncodeMode || (exports.MaxiCodeEncodeMode = {}));
(function (MaxiCodeMode) {
  MaxiCodeMode["Mode2"] = "Mode2";
  MaxiCodeMode["Mode3"] = "Mode3";
  MaxiCodeMode["Mode4"] = "Mode4";
  MaxiCodeMode["Mode5"] = "Mode5";
  MaxiCodeMode["Mode6"] = "Mode6";
})(exports.MaxiCodeMode || (exports.MaxiCodeMode = {}));
/**
 * MaxiCode parameters.
 */
class MaxiCodeParams {
  static getAttributeTypeMap() {
    return MaxiCodeParams.attributeTypeMap;
  }
}
MaxiCodeParams.attributeTypeMap = [{
  name: 'aspectRatio',
  baseName: 'AspectRatio',
  type: 'number'
}, {
  name: 'mode',
  baseName: 'Mode',
  type: 'MaxiCodeMode'
}, {
  name: 'encodeMode',
  baseName: 'EncodeMode',
  type: 'MaxiCodeEncodeMode'
}];
/**
 * Error
 */
class ModelError {
  static getAttributeTypeMap() {
    return ModelError.attributeTypeMap;
  }
}
ModelError.attributeTypeMap = [{
  name: 'code',
  baseName: 'Code',
  type: 'string'
}, {
  name: 'message',
  baseName: 'Message',
  type: 'string'
}, {
  name: 'description',
  baseName: 'Description',
  type: 'string'
}, {
  name: 'innerError',
  baseName: 'InnerError',
  type: 'ErrorDetails'
}];
/**
 * Object exists
 */
class ObjectExist {
  static getAttributeTypeMap() {
    return ObjectExist.attributeTypeMap;
  }
}
ObjectExist.attributeTypeMap = [{
  name: 'exists',
  baseName: 'Exists',
  type: 'boolean'
}, {
  name: 'isFolder',
  baseName: 'IsFolder',
  type: 'boolean'
}];
/**
 * Padding around barcode.
 */
class Padding {
  static getAttributeTypeMap() {
    return Padding.attributeTypeMap;
  }
}
Padding.attributeTypeMap = [{
  name: 'left',
  baseName: 'Left',
  type: 'number'
}, {
  name: 'right',
  baseName: 'Right',
  type: 'number'
}, {
  name: 'top',
  baseName: 'Top',
  type: 'number'
}, {
  name: 'bottom',
  baseName: 'Bottom',
  type: 'number'
}];
/**
 * PatchCode parameters.
 */
class PatchCodeParams {
  static getAttributeTypeMap() {
    return PatchCodeParams.attributeTypeMap;
  }
}
PatchCodeParams.attributeTypeMap = [{
  name: 'extraBarcodeText',
  baseName: 'ExtraBarcodeText',
  type: 'string'
}, {
  name: 'patchFormat',
  baseName: 'PatchFormat',
  type: 'PatchFormat'
}];
(function (PatchFormat) {
  PatchFormat["PatchOnly"] = "PatchOnly";
  PatchFormat["A4"] = "A4";
  PatchFormat["A4LANDSCAPE"] = "A4_LANDSCAPE";
  PatchFormat["USLetter"] = "US_Letter";
  PatchFormat["USLetterLANDSCAPE"] = "US_Letter_LANDSCAPE";
})(exports.PatchFormat || (exports.PatchFormat = {}));
(function (Pdf417CompactionMode) {
  Pdf417CompactionMode["Auto"] = "Auto";
  Pdf417CompactionMode["Text"] = "Text";
  Pdf417CompactionMode["Numeric"] = "Numeric";
  Pdf417CompactionMode["Binary"] = "Binary";
})(exports.Pdf417CompactionMode || (exports.Pdf417CompactionMode = {}));
(function (Pdf417ErrorLevel) {
  Pdf417ErrorLevel["Level0"] = "Level0";
  Pdf417ErrorLevel["Level1"] = "Level1";
  Pdf417ErrorLevel["Level2"] = "Level2";
  Pdf417ErrorLevel["Level3"] = "Level3";
  Pdf417ErrorLevel["Level4"] = "Level4";
  Pdf417ErrorLevel["Level5"] = "Level5";
  Pdf417ErrorLevel["Level6"] = "Level6";
  Pdf417ErrorLevel["Level7"] = "Level7";
  Pdf417ErrorLevel["Level8"] = "Level8";
})(exports.Pdf417ErrorLevel || (exports.Pdf417ErrorLevel = {}));
(function (Pdf417MacroTerminator) {
  Pdf417MacroTerminator["Auto"] = "Auto";
  Pdf417MacroTerminator["None"] = "None";
  Pdf417MacroTerminator["Set"] = "Set";
})(exports.Pdf417MacroTerminator || (exports.Pdf417MacroTerminator = {}));
/**
 * PDF417 parameters.
 */
class Pdf417Params {
  static getAttributeTypeMap() {
    return Pdf417Params.attributeTypeMap;
  }
}
Pdf417Params.attributeTypeMap = [{
  name: 'aspectRatio',
  baseName: 'AspectRatio',
  type: 'number'
}, {
  name: 'textEncoding',
  baseName: 'TextEncoding',
  type: 'string'
}, {
  name: 'columns',
  baseName: 'Columns',
  type: 'number'
}, {
  name: 'compactionMode',
  baseName: 'CompactionMode',
  type: 'Pdf417CompactionMode'
}, {
  name: 'errorLevel',
  baseName: 'ErrorLevel',
  type: 'Pdf417ErrorLevel'
}, {
  name: 'macroFileID',
  baseName: 'MacroFileID',
  type: 'number'
}, {
  name: 'macroSegmentID',
  baseName: 'MacroSegmentID',
  type: 'number'
}, {
  name: 'macroSegmentsCount',
  baseName: 'MacroSegmentsCount',
  type: 'number'
}, {
  name: 'rows',
  baseName: 'Rows',
  type: 'number'
}, {
  name: 'truncate',
  baseName: 'Truncate',
  type: 'boolean'
}, {
  name: 'pdf417ECIEncoding',
  baseName: 'Pdf417ECIEncoding',
  type: 'ECIEncodings'
}, {
  name: 'isReaderInitialization',
  baseName: 'IsReaderInitialization',
  type: 'boolean'
}, {
  name: 'macroTimeStamp',
  baseName: 'MacroTimeStamp',
  type: 'Date'
}, {
  name: 'macroSender',
  baseName: 'MacroSender',
  type: 'string'
}, {
  name: 'macroFileSize',
  baseName: 'MacroFileSize',
  type: 'number'
}, {
  name: 'macroChecksum',
  baseName: 'MacroChecksum',
  type: 'number'
}, {
  name: 'macroFileName',
  baseName: 'MacroFileName',
  type: 'string'
}, {
  name: 'macroAddressee',
  baseName: 'MacroAddressee',
  type: 'string'
}, {
  name: 'macroECIEncoding',
  baseName: 'MacroECIEncoding',
  type: 'ECIEncodings'
}, {
  name: 'code128Emulation',
  baseName: 'Code128Emulation',
  type: 'Code128Emulation'
}, {
  name: 'pdf417MacroTerminator',
  baseName: 'Pdf417MacroTerminator',
  type: 'Pdf417MacroTerminator'
}];
/**
 * Postal parameters. Used for Postnet, Planet.
 */
class PostalParams {
  static getAttributeTypeMap() {
    return PostalParams.attributeTypeMap;
  }
}
PostalParams.attributeTypeMap = [{
  name: 'shortBarHeight',
  baseName: 'ShortBarHeight',
  type: 'number'
}];
(function (PresetType) {
  PresetType["HighPerformance"] = "HighPerformance";
  PresetType["NormalQuality"] = "NormalQuality";
  PresetType["HighQualityDetection"] = "HighQualityDetection";
  PresetType["MaxQualityDetection"] = "MaxQualityDetection";
  PresetType["HighQuality"] = "HighQuality";
  PresetType["MaxBarCodes"] = "MaxBarCodes";
})(exports.PresetType || (exports.PresetType = {}));
(function (QREncodeMode) {
  QREncodeMode["Auto"] = "Auto";
  QREncodeMode["Bytes"] = "Bytes";
  QREncodeMode["Utf8BOM"] = "Utf8BOM";
  QREncodeMode["Utf16BEBOM"] = "Utf16BEBOM";
  QREncodeMode["ECIEncoding"] = "ECIEncoding";
  QREncodeMode["ExtendedCodetext"] = "ExtendedCodetext";
})(exports.QREncodeMode || (exports.QREncodeMode = {}));
(function (QREncodeType) {
  QREncodeType["Auto"] = "Auto";
  QREncodeType["ForceQR"] = "ForceQR";
  QREncodeType["ForceMicroQR"] = "ForceMicroQR";
})(exports.QREncodeType || (exports.QREncodeType = {}));
(function (QRErrorLevel) {
  QRErrorLevel["LevelL"] = "LevelL";
  QRErrorLevel["LevelM"] = "LevelM";
  QRErrorLevel["LevelQ"] = "LevelQ";
  QRErrorLevel["LevelH"] = "LevelH";
})(exports.QRErrorLevel || (exports.QRErrorLevel = {}));
(function (QRVersion) {
  QRVersion["Auto"] = "Auto";
  QRVersion["Version01"] = "Version01";
  QRVersion["Version02"] = "Version02";
  QRVersion["Version03"] = "Version03";
  QRVersion["Version04"] = "Version04";
  QRVersion["Version05"] = "Version05";
  QRVersion["Version06"] = "Version06";
  QRVersion["Version07"] = "Version07";
  QRVersion["Version08"] = "Version08";
  QRVersion["Version09"] = "Version09";
  QRVersion["Version10"] = "Version10";
  QRVersion["Version11"] = "Version11";
  QRVersion["Version12"] = "Version12";
  QRVersion["Version13"] = "Version13";
  QRVersion["Version14"] = "Version14";
  QRVersion["Version15"] = "Version15";
  QRVersion["Version16"] = "Version16";
  QRVersion["Version17"] = "Version17";
  QRVersion["Version18"] = "Version18";
  QRVersion["Version19"] = "Version19";
  QRVersion["Version20"] = "Version20";
  QRVersion["Version21"] = "Version21";
  QRVersion["Version22"] = "Version22";
  QRVersion["Version23"] = "Version23";
  QRVersion["Version24"] = "Version24";
  QRVersion["Version25"] = "Version25";
  QRVersion["Version26"] = "Version26";
  QRVersion["Version27"] = "Version27";
  QRVersion["Version28"] = "Version28";
  QRVersion["Version29"] = "Version29";
  QRVersion["Version30"] = "Version30";
  QRVersion["Version31"] = "Version31";
  QRVersion["Version32"] = "Version32";
  QRVersion["Version33"] = "Version33";
  QRVersion["Version34"] = "Version34";
  QRVersion["Version35"] = "Version35";
  QRVersion["Version36"] = "Version36";
  QRVersion["Version37"] = "Version37";
  QRVersion["Version38"] = "Version38";
  QRVersion["Version39"] = "Version39";
  QRVersion["Version40"] = "Version40";
  QRVersion["VersionM1"] = "VersionM1";
  QRVersion["VersionM2"] = "VersionM2";
  QRVersion["VersionM3"] = "VersionM3";
  QRVersion["VersionM4"] = "VersionM4";
})(exports.QRVersion || (exports.QRVersion = {}));
/**
 * QR parameters.
 */
class QrParams {
  static getAttributeTypeMap() {
    return QrParams.attributeTypeMap;
  }
}
QrParams.attributeTypeMap = [{
  name: 'aspectRatio',
  baseName: 'AspectRatio',
  type: 'number'
}, {
  name: 'textEncoding',
  baseName: 'TextEncoding',
  type: 'string'
}, {
  name: 'encodeType',
  baseName: 'EncodeType',
  type: 'QREncodeType'
}, {
  name: 'eCIEncoding',
  baseName: 'ECIEncoding',
  type: 'ECIEncodings'
}, {
  name: 'encodeMode',
  baseName: 'EncodeMode',
  type: 'QREncodeMode'
}, {
  name: 'errorLevel',
  baseName: 'ErrorLevel',
  type: 'QRErrorLevel'
}, {
  name: 'version',
  baseName: 'Version',
  type: 'QRVersion'
}, {
  name: 'structuredAppend',
  baseName: 'StructuredAppend',
  type: 'StructuredAppend'
}];
/**
 * Represents BarcodeReader object.
 */
class ReaderParams {
  static getAttributeTypeMap() {
    return ReaderParams.attributeTypeMap;
  }
}
ReaderParams.attributeTypeMap = [{
  name: 'type',
  baseName: 'Type',
  type: 'DecodeBarcodeType'
}, {
  name: 'checksumValidation',
  baseName: 'ChecksumValidation',
  type: 'ChecksumValidation'
}, {
  name: 'detectEncoding',
  baseName: 'DetectEncoding',
  type: 'boolean'
}, {
  name: 'preset',
  baseName: 'Preset',
  type: 'PresetType'
}, {
  name: 'rectX',
  baseName: 'RectX',
  type: 'number'
}, {
  name: 'rectY',
  baseName: 'RectY',
  type: 'number'
}, {
  name: 'rectWidth',
  baseName: 'RectWidth',
  type: 'number'
}, {
  name: 'rectHeight',
  baseName: 'RectHeight',
  type: 'number'
}, {
  name: 'stripFNC',
  baseName: 'StripFNC',
  type: 'boolean'
}, {
  name: 'timeout',
  baseName: 'Timeout',
  type: 'number'
}, {
  name: 'medianSmoothingWindowSize',
  baseName: 'MedianSmoothingWindowSize',
  type: 'number'
}, {
  name: 'allowMedianSmoothing',
  baseName: 'AllowMedianSmoothing',
  type: 'boolean'
}, {
  name: 'allowComplexBackground',
  baseName: 'AllowComplexBackground',
  type: 'boolean'
}, {
  name: 'allowDatamatrixIndustrialBarcodes',
  baseName: 'AllowDatamatrixIndustrialBarcodes',
  type: 'boolean'
}, {
  name: 'allowDecreasedImage',
  baseName: 'AllowDecreasedImage',
  type: 'boolean'
}, {
  name: 'allowDetectScanGap',
  baseName: 'AllowDetectScanGap',
  type: 'boolean'
}, {
  name: 'allowIncorrectBarcodes',
  baseName: 'AllowIncorrectBarcodes',
  type: 'boolean'
}, {
  name: 'allowInvertImage',
  baseName: 'AllowInvertImage',
  type: 'boolean'
}, {
  name: 'allowMicroWhiteSpotsRemoving',
  baseName: 'AllowMicroWhiteSpotsRemoving',
  type: 'boolean'
}, {
  name: 'allowOneDFastBarcodesDetector',
  baseName: 'AllowOneDFastBarcodesDetector',
  type: 'boolean'
}, {
  name: 'allowOneDWipedBarsRestoration',
  baseName: 'AllowOneDWipedBarsRestoration',
  type: 'boolean'
}, {
  name: 'allowQRMicroQrRestoration',
  baseName: 'AllowQRMicroQrRestoration',
  type: 'boolean'
}, {
  name: 'allowRegularImage',
  baseName: 'AllowRegularImage',
  type: 'boolean'
}, {
  name: 'allowSaltAndPepperFiltering',
  baseName: 'AllowSaltAndPepperFiltering',
  type: 'boolean'
}, {
  name: 'allowWhiteSpotsRemoving',
  baseName: 'AllowWhiteSpotsRemoving',
  type: 'boolean'
}, {
  name: 'checkMore1DVariants',
  baseName: 'CheckMore1DVariants',
  type: 'boolean'
}, {
  name: 'fastScanOnly',
  baseName: 'FastScanOnly',
  type: 'boolean'
}, {
  name: 'regionLikelihoodThresholdPercent',
  baseName: 'RegionLikelihoodThresholdPercent',
  type: 'number'
}, {
  name: 'scanWindowSizes',
  baseName: 'ScanWindowSizes',
  type: 'Array<number>'
}, {
  name: 'similarity',
  baseName: 'Similarity',
  type: 'number'
}, {
  name: 'skipDiagonalSearch',
  baseName: 'SkipDiagonalSearch',
  type: 'boolean'
}, {
  name: 'readTinyBarcodes',
  baseName: 'ReadTinyBarcodes',
  type: 'boolean'
}, {
  name: 'australianPostEncodingTable',
  baseName: 'AustralianPostEncodingTable',
  type: 'CustomerInformationInterpretingType'
}, {
  name: 'ignoreEndingFillingPatternsForCTable',
  baseName: 'IgnoreEndingFillingPatternsForCTable',
  type: 'boolean'
}];
/**
 * Wrapper around Drawing.Point for proper specification.
 */
class RegionPoint {
  static getAttributeTypeMap() {
    return RegionPoint.attributeTypeMap;
  }
}
RegionPoint.attributeTypeMap = [{
  name: 'X',
  baseName: 'X',
  type: 'number'
}, {
  name: 'Y',
  baseName: 'Y',
  type: 'number'
}];
/**
 * Created image info.
 */
class ResultImageInfo {
  static getAttributeTypeMap() {
    return ResultImageInfo.attributeTypeMap;
  }
}
ResultImageInfo.attributeTypeMap = [{
  name: 'fileSize',
  baseName: 'FileSize',
  type: 'number'
}, {
  name: 'imageWidth',
  baseName: 'ImageWidth',
  type: 'number'
}, {
  name: 'imageHeight',
  baseName: 'ImageHeight',
  type: 'number'
}];
/**
 * Storage exists
 */
class StorageExist {
  static getAttributeTypeMap() {
    return StorageExist.attributeTypeMap;
  }
}
StorageExist.attributeTypeMap = [{
  name: 'exists',
  baseName: 'Exists',
  type: 'boolean'
}];
/**
 * File or folder information
 */
class StorageFile {
  static getAttributeTypeMap() {
    return StorageFile.attributeTypeMap;
  }
}
StorageFile.attributeTypeMap = [{
  name: 'name',
  baseName: 'Name',
  type: 'string'
}, {
  name: 'isFolder',
  baseName: 'IsFolder',
  type: 'boolean'
}, {
  name: 'modifiedDate',
  baseName: 'ModifiedDate',
  type: 'Date'
}, {
  name: 'size',
  baseName: 'Size',
  type: 'number'
}, {
  name: 'path',
  baseName: 'Path',
  type: 'string'
}];
/**
 * QR structured append parameters.
 */
class StructuredAppend {
  static getAttributeTypeMap() {
    return StructuredAppend.attributeTypeMap;
  }
}
StructuredAppend.attributeTypeMap = [{
  name: 'sequenceIndicator',
  baseName: 'SequenceIndicator',
  type: 'number'
}, {
  name: 'totalCount',
  baseName: 'TotalCount',
  type: 'number'
}, {
  name: 'parityByte',
  baseName: 'ParityByte',
  type: 'number'
}];
(function (TextAlignment) {
  TextAlignment["Left"] = "Left";
  TextAlignment["Center"] = "Center";
  TextAlignment["Right"] = "Right";
})(exports.TextAlignment || (exports.TextAlignment = {}));
class FileVersion {
  static getAttributeTypeMap() {
    return FileVersion.attributeTypeMap;
  }
}
FileVersion.attributeTypeMap = [{
  name: 'name',
  baseName: 'Name',
  type: 'string'
}, {
  name: 'isFolder',
  baseName: 'IsFolder',
  type: 'boolean'
}, {
  name: 'modifiedDate',
  baseName: 'ModifiedDate',
  type: 'Date'
}, {
  name: 'size',
  baseName: 'Size',
  type: 'number'
}, {
  name: 'path',
  baseName: 'Path',
  type: 'string'
}, {
  name: 'versionId',
  baseName: 'VersionId',
  type: 'string'
}, {
  name: 'isLatest',
  baseName: 'IsLatest',
  type: 'boolean'
}];
// BarcodeApi
/**
 * Generate barcode.
 */
class GetBarcodeGenerateRequest {
  /**
   * @param type Type of barcode to generate.
   
   * @param text Text to encode.
   */
  constructor(type, text) {
    this.type = type;
    this.text = text;
  }
}
/**
 * Recognize barcode from a file on server.
 */
class GetBarcodeRecognizeRequest {
  /**
   * @param name The image file name.
   */
  constructor(name) {
    this.name = name;
  }
}
/**
 * Recognize barcode from an url or from request body. Request body can contain raw data bytes of the image with content-type \"application/octet-stream\". An image can also be passed as a form field.
 */
class PostBarcodeRecognizeFromUrlOrContentRequest {}
/**
 * Generate multiple barcodes and return in response stream
 */
class PostGenerateMultipleRequest {
  /**
   * @param generatorParamsList List of barcodes
   */
  constructor(generatorParamsList) {
    /**
     * Format to return stream in
     */
    this['format'] = 'png';
    this.generatorParamsList = generatorParamsList;
  }
}
/**
 * Generate barcode and save on server (from query params or from file with json or xml content)
 */
class PutBarcodeGenerateFileRequest {
  /**
   * @param name The image file name.
   
   * @param type Type of barcode to generate.
   
   * @param text Text to encode.
   */
  constructor(name, type, text) {
    this.name = name;
    this.type = type;
    this.text = text;
  }
}
/**
 * Recognition of a barcode from file on server with parameters in body.
 */
class PutBarcodeRecognizeFromBodyRequest {
  /**
   * @param name The image file name.
   
   * @param readerParams BarcodeReader object with parameters.
   */
  constructor(name, readerParams) {
    this.name = name;
    this.readerParams = readerParams;
  }
}
/**
 * Generate image with multiple barcodes and put new file on server
 */
class PutGenerateMultipleRequest {
  /**
   * @param name New filename
   
   * @param generatorParamsList List of barcodes
   */
  constructor(name, generatorParamsList) {
    /**
     * Format of file
     */
    this['format'] = 'png';
    this.name = name;
    this.generatorParamsList = generatorParamsList;
  }
}
// FileApi
/**
 * Copy file
 */
class CopyFileRequest {
  /**
   * @param srcPath Source file path e.g. '/folder/file.ext'
   
   * @param destPath Destination file path
   */
  constructor(srcPath, destPath) {
    this.srcPath = srcPath;
    this.destPath = destPath;
  }
}
/**
 * Delete file
 */
class DeleteFileRequest {
  /**
   * @param path File path e.g. '/folder/file.ext'
   */
  constructor(path) {
    this.path = path;
  }
}
/**
 * Download file
 */
class DownloadFileRequest {
  /**
   * @param path File path e.g. '/folder/file.ext'
   */
  constructor(path) {
    this.path = path;
  }
}
/**
 * Move file
 */
class MoveFileRequest {
  /**
   * @param srcPath Source file path e.g. '/src.ext'
   
   * @param destPath Destination file path e.g. '/dest.ext'
   */
  constructor(srcPath, destPath) {
    this.srcPath = srcPath;
    this.destPath = destPath;
  }
}
/**
 * Upload file
 */
class UploadFileRequest {
  /**
   * @param path Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext
  If the content is multipart and path does not contains the file name it tries to get them from filename parameter
  from Content-Disposition header.
   
   * @param file File to upload
   */
  constructor(path, file) {
    this.path = path;
    this.file = file;
  }
}
// FolderApi
/**
 * Copy folder
 */
class CopyFolderRequest {
  /**
   * @param srcPath Source folder path e.g. '/src'
   
   * @param destPath Destination folder path e.g. '/dst'
   */
  constructor(srcPath, destPath) {
    this.srcPath = srcPath;
    this.destPath = destPath;
  }
}
/**
 * Create the folder
 */
class CreateFolderRequest {
  /**
   * @param path Folder path to create e.g. 'folder_1/folder_2/'
   */
  constructor(path) {
    this.path = path;
  }
}
/**
 * Delete folder
 */
class DeleteFolderRequest {
  /**
   * @param path Folder path e.g. '/folder'
   */
  constructor(path) {
    /**
     * Enable to delete folders, subfolders and files
     */
    this['recursive'] = false;
    this.path = path;
  }
}
/**
 * Get all files and folders within a folder
 */
class GetFilesListRequest {
  /**
   * @param path Folder path e.g. '/folder'
   */
  constructor(path) {
    this.path = path;
  }
}
/**
 * Move folder
 */
class MoveFolderRequest {
  /**
   * @param srcPath Folder path to move e.g. '/folder'
   
   * @param destPath Destination folder path to move to e.g '/dst'
   */
  constructor(srcPath, destPath) {
    this.srcPath = srcPath;
    this.destPath = destPath;
  }
}
// StorageApi
/**
 * Get disc usage
 */
class GetDiscUsageRequest {}
/**
 * Get file versions
 */
class GetFileVersionsRequest {
  /**
   * @param path File path e.g. '/file.ext'
   */
  constructor(path) {
    this.path = path;
  }
}
/**
 * Check if file or folder exists
 */
class ObjectExistsRequest {
  /**
   * @param path File or folder path e.g. '/file.ext' or '/folder'
   */
  constructor(path) {
    this.path = path;
  }
}
/**
 * Check if storage exists
 */
class StorageExistsRequest {
  /**
   * @param storageName Storage name
   */
  constructor(storageName) {
    this.storageName = storageName;
  }
}

/*
* MIT License

* Copyright (c) 2023 Aspose Pty Ltd

* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:

* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/
let primitives = ['string', 'boolean', 'double', 'integer', 'long', 'float', 'number', 'any'];
class ObjectSerializer {
  static findCorrectType(data, expectedType) {
    if (data == null) {
      return expectedType;
    }
    if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
      return expectedType;
    }
    if (expectedType === 'Date') {
      return expectedType;
    }
    if (enumsMap[expectedType]) {
      return expectedType;
    }
    if (!typeMap[expectedType]) {
      return expectedType; // w/e we don't know the type
    }
    // Check the discriminator
    let discriminatorProperty = typeMap[expectedType].discriminator;
    if (discriminatorProperty == null) {
      return expectedType; // the type does not have a discriminator. use it.
    }

    if (data[discriminatorProperty]) {
      return data[discriminatorProperty]; // use the type given in the discriminator
    }

    return expectedType; // discriminator was not present (or an empty string)
  }

  static serialize(data, type) {
    if (data == null) {
      return data;
    }
    if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data;
    }
    if (type.lastIndexOf('Array<', 0) === 0) {
      // string.startsWith pre es6
      let subType = type.replace('Array<', ''); // Array<Type> => Type>
      subType = subType.substring(0, subType.length - 1); // Type> => Type
      let transformedData = [];
      for (let index in data) {
        let date = data[index];
        transformedData.push(ObjectSerializer.serialize(date, subType));
      }
      return transformedData;
    }
    if (type === 'Date') {
      return data.toString();
    }
    if (enumsMap[type]) {
      return enumsMap[type][data];
    }
    if (!typeMap[type]) {
      // in case we don't know the type
      return data;
    }
    // get the map for the correct type.
    let attributeTypes = typeMap[type].getAttributeTypeMap();
    let instance = {};
    for (let index in attributeTypes) {
      let attributeType = attributeTypes[index];
      instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
    }
    return instance;
  }
  static deserialize(data, type) {
    // polymorphism may change the actual type.
    type = ObjectSerializer.findCorrectType(data, type);
    if (data == null) {
      return data;
    }
    if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data;
    }
    if (type.lastIndexOf('Array<', 0) === 0) {
      // string.startsWith pre es6
      let subType = type.replace('Array<', ''); // Array<Type> => Type>
      subType = subType.substring(0, subType.length - 1); // Type> => Type
      let transformedData = [];
      for (let index in data) {
        let date = data[index];
        transformedData.push(ObjectSerializer.deserialize(date, subType));
      }
      return transformedData;
    }
    if (type === 'Date') {
      return new Date(data);
    }
    if (enumsMap[type]) {
      // is Enum
      return data;
    }
    if (!typeMap[type]) {
      // don't know the type
      return data;
    }
    if (typeof data === 'string') {
      // data should be deserialized before usage
      data = JSON.parse(data);
    }
    let instance = new typeMap[type]();
    let attributeTypes = typeMap[type].getAttributeTypeMap();
    for (const attributeType of attributeTypes) {
      const key = attributeType.baseName.replace(/^(.)/, $1 => {
        return $1.toLowerCase();
      });
      instance[attributeType.name] = ObjectSerializer.deserialize(data[key], attributeType.type);
    }
    return instance;
  }
}
let enumsMap = {
  AutoSizeMode: exports.AutoSizeMode,
  AvailableGraphicsUnit: exports.AvailableGraphicsUnit,
  AztecSymbolMode: exports.AztecSymbolMode,
  BorderDashStyle: exports.BorderDashStyle,
  ChecksumValidation: exports.ChecksumValidation,
  CodabarChecksumMode: exports.CodabarChecksumMode,
  CodabarSymbol: exports.CodabarSymbol,
  Code128Emulation: exports.Code128Emulation,
  Code128EncodeMode: exports.Code128EncodeMode,
  CodeLocation: exports.CodeLocation,
  CustomerInformationInterpretingType: exports.CustomerInformationInterpretingType,
  DataMatrixEccType: exports.DataMatrixEccType,
  DataMatrixEncodeMode: exports.DataMatrixEncodeMode,
  DecodeBarcodeType: exports.DecodeBarcodeType,
  DotCodeEncodeMode: exports.DotCodeEncodeMode,
  ECIEncodings: exports.ECIEncodings,
  EnableChecksum: exports.EnableChecksum,
  EncodeBarcodeType: exports.EncodeBarcodeType,
  FontMode: exports.FontMode,
  FontStyle: exports.FontStyle,
  ITF14BorderType: exports.ITF14BorderType,
  MacroCharacter: exports.MacroCharacter,
  MaxiCodeEncodeMode: exports.MaxiCodeEncodeMode,
  MaxiCodeMode: exports.MaxiCodeMode,
  PatchFormat: exports.PatchFormat,
  Pdf417CompactionMode: exports.Pdf417CompactionMode,
  Pdf417ErrorLevel: exports.Pdf417ErrorLevel,
  Pdf417MacroTerminator: exports.Pdf417MacroTerminator,
  PresetType: exports.PresetType,
  QREncodeMode: exports.QREncodeMode,
  QREncodeType: exports.QREncodeType,
  QRErrorLevel: exports.QRErrorLevel,
  QRVersion: exports.QRVersion,
  TextAlignment: exports.TextAlignment
};
let typeMap = {
  ApiError: ApiError,
  ApiErrorResponse: ApiErrorResponse,
  AustralianPostParams: AustralianPostParams,
  AztecParams: AztecParams,
  BarcodeResponse: BarcodeResponse,
  BarcodeResponseList: BarcodeResponseList,
  CaptionParams: CaptionParams,
  CodabarParams: CodabarParams,
  CodablockParams: CodablockParams,
  Code128Params: Code128Params,
  Code16KParams: Code16KParams,
  CouponParams: CouponParams,
  DataBarParams: DataBarParams,
  DataMatrixParams: DataMatrixParams,
  DiscUsage: DiscUsage,
  DotCodeParams: DotCodeParams,
  ErrorDetails: ErrorDetails,
  FileVersions: FileVersions,
  FilesList: FilesList,
  FilesUploadResult: FilesUploadResult,
  FontParams: FontParams,
  GeneratorParams: GeneratorParams,
  GeneratorParamsList: GeneratorParamsList,
  ITFParams: ITFParams,
  MaxiCodeParams: MaxiCodeParams,
  ModelError: ModelError,
  ObjectExist: ObjectExist,
  Padding: Padding,
  PatchCodeParams: PatchCodeParams,
  Pdf417Params: Pdf417Params,
  PostalParams: PostalParams,
  QrParams: QrParams,
  ReaderParams: ReaderParams,
  RegionPoint: RegionPoint,
  ResultImageInfo: ResultImageInfo,
  StorageExist: StorageExist,
  StorageFile: StorageFile,
  StructuredAppend: StructuredAppend,
  FileVersion: FileVersion
};
class BarcodeApi {
  constructor(configuration) {
    this.defaultHeaders = {};
    this._configuration = configuration;
    this._client = new HttpClient();
  }
  /**
   *
   * @summary Generate barcode.
   * @param request GetBarcodeGenerateRequest
   */
  async getBarcodeGenerate(request) {
    const requestPath = this._configuration.getApiBaseUrl() + '/barcode/generate';
    let requestQueryParameters = {};
    let requestHeaderParams = Object.assign({}, this.defaultHeaders);
    // verify required parameter 'request.type' is not null or undefined
    if (request.type == null) {
      throw new Error('Required parameter request.type was null or undefined when calling getBarcodeGenerate.');
    }
    // verify required parameter 'request.text' is not null or undefined
    if (request.text == null) {
      throw new Error('Required parameter request.text was null or undefined when calling getBarcodeGenerate.');
    }
    if (request.type != null) {
      requestQueryParameters['Type'] = ObjectSerializer.serialize(request.type, "'Codabar' | 'Code11' | 'Code39Standard' | 'Code39Extended' | 'Code93Standard' | 'Code93Extended' | 'Code128' | 'GS1Code128' | 'EAN8' | 'EAN13' | 'EAN14' | 'SCC14' | 'SSCC18' | 'UPCA' | 'UPCE' | 'ISBN' | 'ISSN' | 'ISMN' | 'Standard2of5' | 'Interleaved2of5' | 'Matrix2of5' | 'ItalianPost25' | 'IATA2of5' | 'ITF14' | 'ITF6' | 'MSI' | 'VIN' | 'DeutschePostIdentcode' | 'DeutschePostLeitcode' | 'OPC' | 'PZN' | 'Code16K' | 'Pharmacode' | 'DataMatrix' | 'QR' | 'Aztec' | 'Pdf417' | 'MacroPdf417' | 'AustraliaPost' | 'Postnet' | 'Planet' | 'OneCode' | 'RM4SCC' | 'DatabarOmniDirectional' | 'DatabarTruncated' | 'DatabarLimited' | 'DatabarExpanded' | 'SingaporePost' | 'GS1DataMatrix' | 'AustralianPosteParcel' | 'SwissPostParcel' | 'PatchCode' | 'DatabarExpandedStacked' | 'DatabarStacked' | 'DatabarStackedOmniDirectional' | 'MicroPdf417' | 'GS1QR' | 'MaxiCode' | 'Code32' | 'DataLogic2of5' | 'DotCode' | 'DutchKIX' | 'UpcaGs1Code128Coupon' | 'UpcaGs1DatabarCoupon' | 'CodablockF' | 'GS1CodablockF' | 'Mailmark' | 'GS1DotCode'");
    }
    if (request.text != null) {
      requestQueryParameters['Text'] = ObjectSerializer.serialize(request.text, 'string');
    }
    if (request.twoDDisplayText != null) {
      requestQueryParameters['TwoDDisplayText'] = ObjectSerializer.serialize(request.twoDDisplayText, 'string');
    }
    if (request.textLocation != null) {
      requestQueryParameters['TextLocation'] = ObjectSerializer.serialize(request.textLocation, "'Below' | 'Above' | 'None'");
    }
    if (request.textAlignment != null) {
      requestQueryParameters['TextAlignment'] = ObjectSerializer.serialize(request.textAlignment, "'Left' | 'Center' | 'Right'");
    }
    if (request.textColor != null) {
      requestQueryParameters['TextColor'] = ObjectSerializer.serialize(request.textColor, 'string');
    }
    if (request.fontSizeMode != null) {
      requestQueryParameters['FontSizeMode'] = ObjectSerializer.serialize(request.fontSizeMode, "'Auto' | 'Manual'");
    }
    if (request.noWrap != null) {
      requestQueryParameters['NoWrap'] = ObjectSerializer.serialize(request.noWrap, 'boolean');
    }
    if (request.resolution != null) {
      requestQueryParameters['Resolution'] = ObjectSerializer.serialize(request.resolution, 'number');
    }
    if (request.resolutionX != null) {
      requestQueryParameters['ResolutionX'] = ObjectSerializer.serialize(request.resolutionX, 'number');
    }
    if (request.resolutionY != null) {
      requestQueryParameters['ResolutionY'] = ObjectSerializer.serialize(request.resolutionY, 'number');
    }
    if (request.dimensionX != null) {
      requestQueryParameters['DimensionX'] = ObjectSerializer.serialize(request.dimensionX, 'number');
    }
    if (request.textSpace != null) {
      requestQueryParameters['TextSpace'] = ObjectSerializer.serialize(request.textSpace, 'number');
    }
    if (request.units != null) {
      requestQueryParameters['Units'] = ObjectSerializer.serialize(request.units, "'Pixel' | 'Point' | 'Inch' | 'Millimeter'");
    }
    if (request.sizeMode != null) {
      requestQueryParameters['SizeMode'] = ObjectSerializer.serialize(request.sizeMode, "'None' | 'Nearest' | 'Interpolation'");
    }
    if (request.barHeight != null) {
      requestQueryParameters['BarHeight'] = ObjectSerializer.serialize(request.barHeight, 'number');
    }
    if (request.imageHeight != null) {
      requestQueryParameters['ImageHeight'] = ObjectSerializer.serialize(request.imageHeight, 'number');
    }
    if (request.imageWidth != null) {
      requestQueryParameters['ImageWidth'] = ObjectSerializer.serialize(request.imageWidth, 'number');
    }
    if (request.rotationAngle != null) {
      requestQueryParameters['RotationAngle'] = ObjectSerializer.serialize(request.rotationAngle, 'number');
    }
    if (request.backColor != null) {
      requestQueryParameters['BackColor'] = ObjectSerializer.serialize(request.backColor, 'string');
    }
    if (request.barColor != null) {
      requestQueryParameters['BarColor'] = ObjectSerializer.serialize(request.barColor, 'string');
    }
    if (request.borderColor != null) {
      requestQueryParameters['BorderColor'] = ObjectSerializer.serialize(request.borderColor, 'string');
    }
    if (request.borderWidth != null) {
      requestQueryParameters['BorderWidth'] = ObjectSerializer.serialize(request.borderWidth, 'number');
    }
    if (request.borderDashStyle != null) {
      requestQueryParameters['BorderDashStyle'] = ObjectSerializer.serialize(request.borderDashStyle, "'Solid' | 'Dash' | 'Dot' | 'DashDot' | 'DashDotDot'");
    }
    if (request.borderVisible != null) {
      requestQueryParameters['BorderVisible'] = ObjectSerializer.serialize(request.borderVisible, 'boolean');
    }
    if (request.enableChecksum != null) {
      requestQueryParameters['EnableChecksum'] = ObjectSerializer.serialize(request.enableChecksum, "'Default' | 'Yes' | 'No'");
    }
    if (request.enableEscape != null) {
      requestQueryParameters['EnableEscape'] = ObjectSerializer.serialize(request.enableEscape, 'boolean');
    }
    if (request.filledBars != null) {
      requestQueryParameters['FilledBars'] = ObjectSerializer.serialize(request.filledBars, 'boolean');
    }
    if (request.alwaysShowChecksum != null) {
      requestQueryParameters['AlwaysShowChecksum'] = ObjectSerializer.serialize(request.alwaysShowChecksum, 'boolean');
    }
    if (request.wideNarrowRatio != null) {
      requestQueryParameters['WideNarrowRatio'] = ObjectSerializer.serialize(request.wideNarrowRatio, 'number');
    }
    if (request.validateText != null) {
      requestQueryParameters['ValidateText'] = ObjectSerializer.serialize(request.validateText, 'boolean');
    }
    if (request.supplementData != null) {
      requestQueryParameters['SupplementData'] = ObjectSerializer.serialize(request.supplementData, 'string');
    }
    if (request.supplementSpace != null) {
      requestQueryParameters['SupplementSpace'] = ObjectSerializer.serialize(request.supplementSpace, 'number');
    }
    if (request.barWidthReduction != null) {
      requestQueryParameters['BarWidthReduction'] = ObjectSerializer.serialize(request.barWidthReduction, 'number');
    }
    if (request.useAntiAlias != null) {
      requestQueryParameters['UseAntiAlias'] = ObjectSerializer.serialize(request.useAntiAlias, 'boolean');
    }
    if (request.format != null) {
      requestQueryParameters['format'] = ObjectSerializer.serialize(request.format, 'string');
    }
    let requestOptions = {
      method: 'GET',
      qs: requestQueryParameters,
      headers: requestHeaderParams,
      uri: requestPath,
      encoding: null
    };
    await this._configuration.authentication.applyToRequest(requestOptions);
    const result = await this._client.requestAsync(requestOptions);
    return {
      response: result.response,
      body: ObjectSerializer.deserialize(result.body, 'Buffer')
    };
  }
  /**
   *
   * @summary Recognize barcode from a file on server.
   * @param request GetBarcodeRecognizeRequest
   */
  async getBarcodeRecognize(request) {
    const requestPath = this._configuration.getApiBaseUrl() + '/barcode/{name}/recognize'.replace('{' + 'name' + '}', String(request.name));
    let requestQueryParameters = {};
    let requestHeaderParams = Object.assign({}, this.defaultHeaders);
    // verify required parameter 'request.name' is not null or undefined
    if (request.name == null) {
      throw new Error('Required parameter request.name was null or undefined when calling getBarcodeRecognize.');
    }
    if (request.type != null) {
      requestQueryParameters['Type'] = ObjectSerializer.serialize(request.type, "'all' | 'AustraliaPost' | 'Aztec' | 'ISBN' | 'Codabar' | 'Code11' | 'Code128' | 'GS1Code128' | 'Code39Extended' | 'Code39Standard' | 'Code93Extended' | 'Code93Standard' | 'DataMatrix' | 'DeutschePostIdentcode' | 'DeutschePostLeitcode' | 'EAN13' | 'EAN14' | 'EAN8' | 'IATA2of5' | 'Interleaved2of5' | 'ISSN' | 'ISMN' | 'ItalianPost25' | 'ITF14' | 'ITF6' | 'MacroPdf417' | 'Matrix2of5' | 'MSI' | 'OneCode' | 'OPC' | 'PatchCode' | 'Pdf417' | 'MicroPdf417' | 'Planet' | 'Postnet' | 'PZN' | 'QR' | 'MicroQR' | 'RM4SCC' | 'SCC14' | 'SSCC18' | 'Standard2of5' | 'Supplement' | 'UPCA' | 'UPCE' | 'VIN' | 'Pharmacode' | 'GS1DataMatrix' | 'DatabarOmniDirectional' | 'DatabarTruncated' | 'DatabarLimited' | 'DatabarExpanded' | 'SwissPostParcel' | 'AustralianPosteParcel' | 'Code16K' | 'DatabarStackedOmniDirectional' | 'DatabarStacked' | 'DatabarExpandedStacked' | 'CompactPdf417' | 'GS1QR' | 'MaxiCode' | 'MicrE13B' | 'Code32' | 'DataLogic2of5' | 'DotCode' | 'DutchKIX' | 'CodablockF' | 'Mailmark' | 'GS1DotCode' | 'HIBCCode39LIC' | 'HIBCCode128LIC' | 'HIBCAztecLIC' | 'HIBCDataMatrixLIC' | 'HIBCQRLIC' | 'HIBCCode39PAS' | 'HIBCCode128PAS' | 'HIBCAztecPAS' | 'HIBCDataMatrixPAS' | 'HIBCQRPAS'");
    }
    if (request.checksumValidation != null) {
      requestQueryParameters['ChecksumValidation'] = ObjectSerializer.serialize(request.checksumValidation, "'Default' | 'On' | 'Off'");
    }
    if (request.detectEncoding != null) {
      requestQueryParameters['DetectEncoding'] = ObjectSerializer.serialize(request.detectEncoding, 'boolean');
    }
    if (request.preset != null) {
      requestQueryParameters['Preset'] = ObjectSerializer.serialize(request.preset, "'HighPerformance' | 'NormalQuality' | 'HighQualityDetection' | 'MaxQualityDetection' | 'HighQuality' | 'MaxBarCodes'");
    }
    if (request.rectX != null) {
      requestQueryParameters['RectX'] = ObjectSerializer.serialize(request.rectX, 'number');
    }
    if (request.rectY != null) {
      requestQueryParameters['RectY'] = ObjectSerializer.serialize(request.rectY, 'number');
    }
    if (request.rectWidth != null) {
      requestQueryParameters['RectWidth'] = ObjectSerializer.serialize(request.rectWidth, 'number');
    }
    if (request.rectHeight != null) {
      requestQueryParameters['RectHeight'] = ObjectSerializer.serialize(request.rectHeight, 'number');
    }
    if (request.stripFNC != null) {
      requestQueryParameters['StripFNC'] = ObjectSerializer.serialize(request.stripFNC, 'boolean');
    }
    if (request.timeout != null) {
      requestQueryParameters['Timeout'] = ObjectSerializer.serialize(request.timeout, 'number');
    }
    if (request.medianSmoothingWindowSize != null) {
      requestQueryParameters['MedianSmoothingWindowSize'] = ObjectSerializer.serialize(request.medianSmoothingWindowSize, 'number');
    }
    if (request.allowMedianSmoothing != null) {
      requestQueryParameters['AllowMedianSmoothing'] = ObjectSerializer.serialize(request.allowMedianSmoothing, 'boolean');
    }
    if (request.allowComplexBackground != null) {
      requestQueryParameters['AllowComplexBackground'] = ObjectSerializer.serialize(request.allowComplexBackground, 'boolean');
    }
    if (request.allowDatamatrixIndustrialBarcodes != null) {
      requestQueryParameters['AllowDatamatrixIndustrialBarcodes'] = ObjectSerializer.serialize(request.allowDatamatrixIndustrialBarcodes, 'boolean');
    }
    if (request.allowDecreasedImage != null) {
      requestQueryParameters['AllowDecreasedImage'] = ObjectSerializer.serialize(request.allowDecreasedImage, 'boolean');
    }
    if (request.allowDetectScanGap != null) {
      requestQueryParameters['AllowDetectScanGap'] = ObjectSerializer.serialize(request.allowDetectScanGap, 'boolean');
    }
    if (request.allowIncorrectBarcodes != null) {
      requestQueryParameters['AllowIncorrectBarcodes'] = ObjectSerializer.serialize(request.allowIncorrectBarcodes, 'boolean');
    }
    if (request.allowInvertImage != null) {
      requestQueryParameters['AllowInvertImage'] = ObjectSerializer.serialize(request.allowInvertImage, 'boolean');
    }
    if (request.allowMicroWhiteSpotsRemoving != null) {
      requestQueryParameters['AllowMicroWhiteSpotsRemoving'] = ObjectSerializer.serialize(request.allowMicroWhiteSpotsRemoving, 'boolean');
    }
    if (request.allowOneDFastBarcodesDetector != null) {
      requestQueryParameters['AllowOneDFastBarcodesDetector'] = ObjectSerializer.serialize(request.allowOneDFastBarcodesDetector, 'boolean');
    }
    if (request.allowOneDWipedBarsRestoration != null) {
      requestQueryParameters['AllowOneDWipedBarsRestoration'] = ObjectSerializer.serialize(request.allowOneDWipedBarsRestoration, 'boolean');
    }
    if (request.allowQRMicroQrRestoration != null) {
      requestQueryParameters['AllowQRMicroQrRestoration'] = ObjectSerializer.serialize(request.allowQRMicroQrRestoration, 'boolean');
    }
    if (request.allowRegularImage != null) {
      requestQueryParameters['AllowRegularImage'] = ObjectSerializer.serialize(request.allowRegularImage, 'boolean');
    }
    if (request.allowSaltAndPepperFiltering != null) {
      requestQueryParameters['AllowSaltAndPepperFiltering'] = ObjectSerializer.serialize(request.allowSaltAndPepperFiltering, 'boolean');
    }
    if (request.allowWhiteSpotsRemoving != null) {
      requestQueryParameters['AllowWhiteSpotsRemoving'] = ObjectSerializer.serialize(request.allowWhiteSpotsRemoving, 'boolean');
    }
    if (request.checkMore1DVariants != null) {
      requestQueryParameters['CheckMore1DVariants'] = ObjectSerializer.serialize(request.checkMore1DVariants, 'boolean');
    }
    if (request.fastScanOnly != null) {
      requestQueryParameters['FastScanOnly'] = ObjectSerializer.serialize(request.fastScanOnly, 'boolean');
    }
    if (request.regionLikelihoodThresholdPercent != null) {
      requestQueryParameters['RegionLikelihoodThresholdPercent'] = ObjectSerializer.serialize(request.regionLikelihoodThresholdPercent, 'number');
    }
    if (request.scanWindowSizes != null) {
      requestQueryParameters['ScanWindowSizes'] = ObjectSerializer.serialize(request.scanWindowSizes, 'Array<number>');
    }
    if (request.similarity != null) {
      requestQueryParameters['Similarity'] = ObjectSerializer.serialize(request.similarity, 'number');
    }
    if (request.skipDiagonalSearch != null) {
      requestQueryParameters['SkipDiagonalSearch'] = ObjectSerializer.serialize(request.skipDiagonalSearch, 'boolean');
    }
    if (request.readTinyBarcodes != null) {
      requestQueryParameters['ReadTinyBarcodes'] = ObjectSerializer.serialize(request.readTinyBarcodes, 'boolean');
    }
    if (request.australianPostEncodingTable != null) {
      requestQueryParameters['AustralianPostEncodingTable'] = ObjectSerializer.serialize(request.australianPostEncodingTable, "'CTable' | 'NTable' | 'Other'");
    }
    if (request.ignoreEndingFillingPatternsForCTable != null) {
      requestQueryParameters['IgnoreEndingFillingPatternsForCTable'] = ObjectSerializer.serialize(request.ignoreEndingFillingPatternsForCTable, 'boolean');
    }
    if (request.storage != null) {
      requestQueryParameters['storage'] = ObjectSerializer.serialize(request.storage, 'string');
    }
    if (request.folder != null) {
      requestQueryParameters['folder'] = ObjectSerializer.serialize(request.folder, 'string');
    }
    let requestOptions = {
      method: 'GET',
      qs: requestQueryParameters,
      headers: requestHeaderParams,
      uri: requestPath
    };
    await this._configuration.authentication.applyToRequest(requestOptions);
    const result = await this._client.requestAsync(requestOptions);
    return {
      response: result.response,
      body: ObjectSerializer.deserialize(result.body, 'BarcodeResponseList')
    };
  }
  /**
   *
   * @summary Recognize barcode from an url or from request body. Request body can contain raw data bytes of the image with content-type \"application/octet-stream\". An image can also be passed as a form field.
   * @param request PostBarcodeRecognizeFromUrlOrContentRequest
   */
  async postBarcodeRecognizeFromUrlOrContent(request) {
    const requestPath = this._configuration.getApiBaseUrl() + '/barcode/recognize';
    let requestQueryParameters = {};
    let requestHeaderParams = Object.assign({}, this.defaultHeaders);
    if (request.type != null) {
      requestQueryParameters['Type'] = ObjectSerializer.serialize(request.type, "'all' | 'AustraliaPost' | 'Aztec' | 'ISBN' | 'Codabar' | 'Code11' | 'Code128' | 'GS1Code128' | 'Code39Extended' | 'Code39Standard' | 'Code93Extended' | 'Code93Standard' | 'DataMatrix' | 'DeutschePostIdentcode' | 'DeutschePostLeitcode' | 'EAN13' | 'EAN14' | 'EAN8' | 'IATA2of5' | 'Interleaved2of5' | 'ISSN' | 'ISMN' | 'ItalianPost25' | 'ITF14' | 'ITF6' | 'MacroPdf417' | 'Matrix2of5' | 'MSI' | 'OneCode' | 'OPC' | 'PatchCode' | 'Pdf417' | 'MicroPdf417' | 'Planet' | 'Postnet' | 'PZN' | 'QR' | 'MicroQR' | 'RM4SCC' | 'SCC14' | 'SSCC18' | 'Standard2of5' | 'Supplement' | 'UPCA' | 'UPCE' | 'VIN' | 'Pharmacode' | 'GS1DataMatrix' | 'DatabarOmniDirectional' | 'DatabarTruncated' | 'DatabarLimited' | 'DatabarExpanded' | 'SwissPostParcel' | 'AustralianPosteParcel' | 'Code16K' | 'DatabarStackedOmniDirectional' | 'DatabarStacked' | 'DatabarExpandedStacked' | 'CompactPdf417' | 'GS1QR' | 'MaxiCode' | 'MicrE13B' | 'Code32' | 'DataLogic2of5' | 'DotCode' | 'DutchKIX' | 'CodablockF' | 'Mailmark' | 'GS1DotCode' | 'HIBCCode39LIC' | 'HIBCCode128LIC' | 'HIBCAztecLIC' | 'HIBCDataMatrixLIC' | 'HIBCQRLIC' | 'HIBCCode39PAS' | 'HIBCCode128PAS' | 'HIBCAztecPAS' | 'HIBCDataMatrixPAS' | 'HIBCQRPAS'");
    }
    if (request.checksumValidation != null) {
      requestQueryParameters['ChecksumValidation'] = ObjectSerializer.serialize(request.checksumValidation, "'Default' | 'On' | 'Off'");
    }
    if (request.detectEncoding != null) {
      requestQueryParameters['DetectEncoding'] = ObjectSerializer.serialize(request.detectEncoding, 'boolean');
    }
    if (request.preset != null) {
      requestQueryParameters['Preset'] = ObjectSerializer.serialize(request.preset, "'HighPerformance' | 'NormalQuality' | 'HighQualityDetection' | 'MaxQualityDetection' | 'HighQuality' | 'MaxBarCodes'");
    }
    if (request.rectX != null) {
      requestQueryParameters['RectX'] = ObjectSerializer.serialize(request.rectX, 'number');
    }
    if (request.rectY != null) {
      requestQueryParameters['RectY'] = ObjectSerializer.serialize(request.rectY, 'number');
    }
    if (request.rectWidth != null) {
      requestQueryParameters['RectWidth'] = ObjectSerializer.serialize(request.rectWidth, 'number');
    }
    if (request.rectHeight != null) {
      requestQueryParameters['RectHeight'] = ObjectSerializer.serialize(request.rectHeight, 'number');
    }
    if (request.stripFNC != null) {
      requestQueryParameters['StripFNC'] = ObjectSerializer.serialize(request.stripFNC, 'boolean');
    }
    if (request.timeout != null) {
      requestQueryParameters['Timeout'] = ObjectSerializer.serialize(request.timeout, 'number');
    }
    if (request.medianSmoothingWindowSize != null) {
      requestQueryParameters['MedianSmoothingWindowSize'] = ObjectSerializer.serialize(request.medianSmoothingWindowSize, 'number');
    }
    if (request.allowMedianSmoothing != null) {
      requestQueryParameters['AllowMedianSmoothing'] = ObjectSerializer.serialize(request.allowMedianSmoothing, 'boolean');
    }
    if (request.allowComplexBackground != null) {
      requestQueryParameters['AllowComplexBackground'] = ObjectSerializer.serialize(request.allowComplexBackground, 'boolean');
    }
    if (request.allowDatamatrixIndustrialBarcodes != null) {
      requestQueryParameters['AllowDatamatrixIndustrialBarcodes'] = ObjectSerializer.serialize(request.allowDatamatrixIndustrialBarcodes, 'boolean');
    }
    if (request.allowDecreasedImage != null) {
      requestQueryParameters['AllowDecreasedImage'] = ObjectSerializer.serialize(request.allowDecreasedImage, 'boolean');
    }
    if (request.allowDetectScanGap != null) {
      requestQueryParameters['AllowDetectScanGap'] = ObjectSerializer.serialize(request.allowDetectScanGap, 'boolean');
    }
    if (request.allowIncorrectBarcodes != null) {
      requestQueryParameters['AllowIncorrectBarcodes'] = ObjectSerializer.serialize(request.allowIncorrectBarcodes, 'boolean');
    }
    if (request.allowInvertImage != null) {
      requestQueryParameters['AllowInvertImage'] = ObjectSerializer.serialize(request.allowInvertImage, 'boolean');
    }
    if (request.allowMicroWhiteSpotsRemoving != null) {
      requestQueryParameters['AllowMicroWhiteSpotsRemoving'] = ObjectSerializer.serialize(request.allowMicroWhiteSpotsRemoving, 'boolean');
    }
    if (request.allowOneDFastBarcodesDetector != null) {
      requestQueryParameters['AllowOneDFastBarcodesDetector'] = ObjectSerializer.serialize(request.allowOneDFastBarcodesDetector, 'boolean');
    }
    if (request.allowOneDWipedBarsRestoration != null) {
      requestQueryParameters['AllowOneDWipedBarsRestoration'] = ObjectSerializer.serialize(request.allowOneDWipedBarsRestoration, 'boolean');
    }
    if (request.allowQRMicroQrRestoration != null) {
      requestQueryParameters['AllowQRMicroQrRestoration'] = ObjectSerializer.serialize(request.allowQRMicroQrRestoration, 'boolean');
    }
    if (request.allowRegularImage != null) {
      requestQueryParameters['AllowRegularImage'] = ObjectSerializer.serialize(request.allowRegularImage, 'boolean');
    }
    if (request.allowSaltAndPepperFiltering != null) {
      requestQueryParameters['AllowSaltAndPepperFiltering'] = ObjectSerializer.serialize(request.allowSaltAndPepperFiltering, 'boolean');
    }
    if (request.allowWhiteSpotsRemoving != null) {
      requestQueryParameters['AllowWhiteSpotsRemoving'] = ObjectSerializer.serialize(request.allowWhiteSpotsRemoving, 'boolean');
    }
    if (request.checkMore1DVariants != null) {
      requestQueryParameters['CheckMore1DVariants'] = ObjectSerializer.serialize(request.checkMore1DVariants, 'boolean');
    }
    if (request.fastScanOnly != null) {
      requestQueryParameters['FastScanOnly'] = ObjectSerializer.serialize(request.fastScanOnly, 'boolean');
    }
    if (request.regionLikelihoodThresholdPercent != null) {
      requestQueryParameters['RegionLikelihoodThresholdPercent'] = ObjectSerializer.serialize(request.regionLikelihoodThresholdPercent, 'number');
    }
    if (request.scanWindowSizes != null) {
      requestQueryParameters['ScanWindowSizes'] = ObjectSerializer.serialize(request.scanWindowSizes, 'Array<number>');
    }
    if (request.similarity != null) {
      requestQueryParameters['Similarity'] = ObjectSerializer.serialize(request.similarity, 'number');
    }
    if (request.skipDiagonalSearch != null) {
      requestQueryParameters['SkipDiagonalSearch'] = ObjectSerializer.serialize(request.skipDiagonalSearch, 'boolean');
    }
    if (request.readTinyBarcodes != null) {
      requestQueryParameters['ReadTinyBarcodes'] = ObjectSerializer.serialize(request.readTinyBarcodes, 'boolean');
    }
    if (request.australianPostEncodingTable != null) {
      requestQueryParameters['AustralianPostEncodingTable'] = ObjectSerializer.serialize(request.australianPostEncodingTable, "'CTable' | 'NTable' | 'Other'");
    }
    if (request.ignoreEndingFillingPatternsForCTable != null) {
      requestQueryParameters['IgnoreEndingFillingPatternsForCTable'] = ObjectSerializer.serialize(request.ignoreEndingFillingPatternsForCTable, 'boolean');
    }
    if (request.url != null) {
      requestQueryParameters['url'] = ObjectSerializer.serialize(request.url, 'string');
    }
    let requestOptions = {
      method: 'POST',
      qs: requestQueryParameters,
      headers: requestHeaderParams,
      uri: requestPath,
      body: request.image
    };
    await this._configuration.authentication.applyToRequest(requestOptions);
    const result = await this._client.requestAsync(requestOptions);
    return {
      response: result.response,
      body: ObjectSerializer.deserialize(result.body, 'BarcodeResponseList')
    };
  }
  /**
   *
   * @summary Generate multiple barcodes and return in response stream
   * @param request PostGenerateMultipleRequest
   */
  async postGenerateMultiple(request) {
    const requestPath = this._configuration.getApiBaseUrl() + '/barcode/generateMultiple';
    let requestQueryParameters = {};
    let requestHeaderParams = Object.assign({}, this.defaultHeaders);
    // verify required parameter 'request.generatorParamsList' is not null or undefined
    if (request.generatorParamsList == null) {
      throw new Error('Required parameter request.generatorParamsList was null or undefined when calling postGenerateMultiple.');
    }
    if (request.format != null) {
      requestQueryParameters['format'] = ObjectSerializer.serialize(request.format, 'string');
    }
    let requestOptions = {
      method: 'POST',
      qs: requestQueryParameters,
      headers: requestHeaderParams,
      uri: requestPath,
      body: ObjectSerializer.serialize(request.generatorParamsList, 'GeneratorParamsList'),
      json: true,
      encoding: null
    };
    await this._configuration.authentication.applyToRequest(requestOptions);
    const result = await this._client.requestAsync(requestOptions);
    return {
      response: result.response,
      body: ObjectSerializer.deserialize(result.body, 'Buffer')
    };
  }
  /**
   *
   * @summary Generate barcode and save on server (from query params or from file with json or xml content)
   * @param request PutBarcodeGenerateFileRequest
   */
  async putBarcodeGenerateFile(request) {
    const requestPath = this._configuration.getApiBaseUrl() + '/barcode/{name}/generate'.replace('{' + 'name' + '}', String(request.name));
    let requestQueryParameters = {};
    let requestHeaderParams = Object.assign({}, this.defaultHeaders);
    // verify required parameter 'request.name' is not null or undefined
    if (request.name == null) {
      throw new Error('Required parameter request.name was null or undefined when calling putBarcodeGenerateFile.');
    }
    // verify required parameter 'request.type' is not null or undefined
    if (request.type == null) {
      throw new Error('Required parameter request.type was null or undefined when calling putBarcodeGenerateFile.');
    }
    // verify required parameter 'request.text' is not null or undefined
    if (request.text == null) {
      throw new Error('Required parameter request.text was null or undefined when calling putBarcodeGenerateFile.');
    }
    if (request.type != null) {
      requestQueryParameters['Type'] = ObjectSerializer.serialize(request.type, "'Codabar' | 'Code11' | 'Code39Standard' | 'Code39Extended' | 'Code93Standard' | 'Code93Extended' | 'Code128' | 'GS1Code128' | 'EAN8' | 'EAN13' | 'EAN14' | 'SCC14' | 'SSCC18' | 'UPCA' | 'UPCE' | 'ISBN' | 'ISSN' | 'ISMN' | 'Standard2of5' | 'Interleaved2of5' | 'Matrix2of5' | 'ItalianPost25' | 'IATA2of5' | 'ITF14' | 'ITF6' | 'MSI' | 'VIN' | 'DeutschePostIdentcode' | 'DeutschePostLeitcode' | 'OPC' | 'PZN' | 'Code16K' | 'Pharmacode' | 'DataMatrix' | 'QR' | 'Aztec' | 'Pdf417' | 'MacroPdf417' | 'AustraliaPost' | 'Postnet' | 'Planet' | 'OneCode' | 'RM4SCC' | 'DatabarOmniDirectional' | 'DatabarTruncated' | 'DatabarLimited' | 'DatabarExpanded' | 'SingaporePost' | 'GS1DataMatrix' | 'AustralianPosteParcel' | 'SwissPostParcel' | 'PatchCode' | 'DatabarExpandedStacked' | 'DatabarStacked' | 'DatabarStackedOmniDirectional' | 'MicroPdf417' | 'GS1QR' | 'MaxiCode' | 'Code32' | 'DataLogic2of5' | 'DotCode' | 'DutchKIX' | 'UpcaGs1Code128Coupon' | 'UpcaGs1DatabarCoupon' | 'CodablockF' | 'GS1CodablockF' | 'Mailmark' | 'GS1DotCode'");
    }
    if (request.text != null) {
      requestQueryParameters['Text'] = ObjectSerializer.serialize(request.text, 'string');
    }
    if (request.twoDDisplayText != null) {
      requestQueryParameters['TwoDDisplayText'] = ObjectSerializer.serialize(request.twoDDisplayText, 'string');
    }
    if (request.textLocation != null) {
      requestQueryParameters['TextLocation'] = ObjectSerializer.serialize(request.textLocation, "'Below' | 'Above' | 'None'");
    }
    if (request.textAlignment != null) {
      requestQueryParameters['TextAlignment'] = ObjectSerializer.serialize(request.textAlignment, "'Left' | 'Center' | 'Right'");
    }
    if (request.textColor != null) {
      requestQueryParameters['TextColor'] = ObjectSerializer.serialize(request.textColor, 'string');
    }
    if (request.fontSizeMode != null) {
      requestQueryParameters['FontSizeMode'] = ObjectSerializer.serialize(request.fontSizeMode, "'Auto' | 'Manual'");
    }
    if (request.noWrap != null) {
      requestQueryParameters['NoWrap'] = ObjectSerializer.serialize(request.noWrap, 'boolean');
    }
    if (request.resolution != null) {
      requestQueryParameters['Resolution'] = ObjectSerializer.serialize(request.resolution, 'number');
    }
    if (request.resolutionX != null) {
      requestQueryParameters['ResolutionX'] = ObjectSerializer.serialize(request.resolutionX, 'number');
    }
    if (request.resolutionY != null) {
      requestQueryParameters['ResolutionY'] = ObjectSerializer.serialize(request.resolutionY, 'number');
    }
    if (request.dimensionX != null) {
      requestQueryParameters['DimensionX'] = ObjectSerializer.serialize(request.dimensionX, 'number');
    }
    if (request.textSpace != null) {
      requestQueryParameters['TextSpace'] = ObjectSerializer.serialize(request.textSpace, 'number');
    }
    if (request.units != null) {
      requestQueryParameters['Units'] = ObjectSerializer.serialize(request.units, "'Pixel' | 'Point' | 'Inch' | 'Millimeter'");
    }
    if (request.sizeMode != null) {
      requestQueryParameters['SizeMode'] = ObjectSerializer.serialize(request.sizeMode, "'None' | 'Nearest' | 'Interpolation'");
    }
    if (request.barHeight != null) {
      requestQueryParameters['BarHeight'] = ObjectSerializer.serialize(request.barHeight, 'number');
    }
    if (request.imageHeight != null) {
      requestQueryParameters['ImageHeight'] = ObjectSerializer.serialize(request.imageHeight, 'number');
    }
    if (request.imageWidth != null) {
      requestQueryParameters['ImageWidth'] = ObjectSerializer.serialize(request.imageWidth, 'number');
    }
    if (request.rotationAngle != null) {
      requestQueryParameters['RotationAngle'] = ObjectSerializer.serialize(request.rotationAngle, 'number');
    }
    if (request.backColor != null) {
      requestQueryParameters['BackColor'] = ObjectSerializer.serialize(request.backColor, 'string');
    }
    if (request.barColor != null) {
      requestQueryParameters['BarColor'] = ObjectSerializer.serialize(request.barColor, 'string');
    }
    if (request.borderColor != null) {
      requestQueryParameters['BorderColor'] = ObjectSerializer.serialize(request.borderColor, 'string');
    }
    if (request.borderWidth != null) {
      requestQueryParameters['BorderWidth'] = ObjectSerializer.serialize(request.borderWidth, 'number');
    }
    if (request.borderDashStyle != null) {
      requestQueryParameters['BorderDashStyle'] = ObjectSerializer.serialize(request.borderDashStyle, "'Solid' | 'Dash' | 'Dot' | 'DashDot' | 'DashDotDot'");
    }
    if (request.borderVisible != null) {
      requestQueryParameters['BorderVisible'] = ObjectSerializer.serialize(request.borderVisible, 'boolean');
    }
    if (request.enableChecksum != null) {
      requestQueryParameters['EnableChecksum'] = ObjectSerializer.serialize(request.enableChecksum, "'Default' | 'Yes' | 'No'");
    }
    if (request.enableEscape != null) {
      requestQueryParameters['EnableEscape'] = ObjectSerializer.serialize(request.enableEscape, 'boolean');
    }
    if (request.filledBars != null) {
      requestQueryParameters['FilledBars'] = ObjectSerializer.serialize(request.filledBars, 'boolean');
    }
    if (request.alwaysShowChecksum != null) {
      requestQueryParameters['AlwaysShowChecksum'] = ObjectSerializer.serialize(request.alwaysShowChecksum, 'boolean');
    }
    if (request.wideNarrowRatio != null) {
      requestQueryParameters['WideNarrowRatio'] = ObjectSerializer.serialize(request.wideNarrowRatio, 'number');
    }
    if (request.validateText != null) {
      requestQueryParameters['ValidateText'] = ObjectSerializer.serialize(request.validateText, 'boolean');
    }
    if (request.supplementData != null) {
      requestQueryParameters['SupplementData'] = ObjectSerializer.serialize(request.supplementData, 'string');
    }
    if (request.supplementSpace != null) {
      requestQueryParameters['SupplementSpace'] = ObjectSerializer.serialize(request.supplementSpace, 'number');
    }
    if (request.barWidthReduction != null) {
      requestQueryParameters['BarWidthReduction'] = ObjectSerializer.serialize(request.barWidthReduction, 'number');
    }
    if (request.useAntiAlias != null) {
      requestQueryParameters['UseAntiAlias'] = ObjectSerializer.serialize(request.useAntiAlias, 'boolean');
    }
    if (request.storage != null) {
      requestQueryParameters['storage'] = ObjectSerializer.serialize(request.storage, 'string');
    }
    if (request.folder != null) {
      requestQueryParameters['folder'] = ObjectSerializer.serialize(request.folder, 'string');
    }
    if (request.format != null) {
      requestQueryParameters['format'] = ObjectSerializer.serialize(request.format, 'string');
    }
    let requestOptions = {
      method: 'PUT',
      qs: requestQueryParameters,
      headers: requestHeaderParams,
      uri: requestPath
    };
    await this._configuration.authentication.applyToRequest(requestOptions);
    const result = await this._client.requestAsync(requestOptions);
    return {
      response: result.response,
      body: ObjectSerializer.deserialize(result.body, 'ResultImageInfo')
    };
  }
  /**
   *
   * @summary Recognition of a barcode from file on server with parameters in body.
   * @param request PutBarcodeRecognizeFromBodyRequest
   */
  async putBarcodeRecognizeFromBody(request) {
    const requestPath = this._configuration.getApiBaseUrl() + '/barcode/{name}/recognize'.replace('{' + 'name' + '}', String(request.name));
    let requestQueryParameters = {};
    let requestHeaderParams = Object.assign({}, this.defaultHeaders);
    // verify required parameter 'request.name' is not null or undefined
    if (request.name == null) {
      throw new Error('Required parameter request.name was null or undefined when calling putBarcodeRecognizeFromBody.');
    }
    // verify required parameter 'request.readerParams' is not null or undefined
    if (request.readerParams == null) {
      throw new Error('Required parameter request.readerParams was null or undefined when calling putBarcodeRecognizeFromBody.');
    }
    if (request.type != null) {
      requestQueryParameters['type'] = ObjectSerializer.serialize(request.type, "'all' | 'AustraliaPost' | 'Aztec' | 'ISBN' | 'Codabar' | 'Code11' | 'Code128' | 'GS1Code128' | 'Code39Extended' | 'Code39Standard' | 'Code93Extended' | 'Code93Standard' | 'DataMatrix' | 'DeutschePostIdentcode' | 'DeutschePostLeitcode' | 'EAN13' | 'EAN14' | 'EAN8' | 'IATA2of5' | 'Interleaved2of5' | 'ISSN' | 'ISMN' | 'ItalianPost25' | 'ITF14' | 'ITF6' | 'MacroPdf417' | 'Matrix2of5' | 'MSI' | 'OneCode' | 'OPC' | 'PatchCode' | 'Pdf417' | 'MicroPdf417' | 'Planet' | 'Postnet' | 'PZN' | 'QR' | 'MicroQR' | 'RM4SCC' | 'SCC14' | 'SSCC18' | 'Standard2of5' | 'Supplement' | 'UPCA' | 'UPCE' | 'VIN' | 'Pharmacode' | 'GS1DataMatrix' | 'DatabarOmniDirectional' | 'DatabarTruncated' | 'DatabarLimited' | 'DatabarExpanded' | 'SwissPostParcel' | 'AustralianPosteParcel' | 'Code16K' | 'DatabarStackedOmniDirectional' | 'DatabarStacked' | 'DatabarExpandedStacked' | 'CompactPdf417' | 'GS1QR' | 'MaxiCode' | 'MicrE13B' | 'Code32' | 'DataLogic2of5' | 'DotCode' | 'DutchKIX' | 'CodablockF' | 'Mailmark' | 'GS1DotCode' | 'HIBCCode39LIC' | 'HIBCCode128LIC' | 'HIBCAztecLIC' | 'HIBCDataMatrixLIC' | 'HIBCQRLIC' | 'HIBCCode39PAS' | 'HIBCCode128PAS' | 'HIBCAztecPAS' | 'HIBCDataMatrixPAS' | 'HIBCQRPAS'");
    }
    if (request.storage != null) {
      requestQueryParameters['storage'] = ObjectSerializer.serialize(request.storage, 'string');
    }
    if (request.folder != null) {
      requestQueryParameters['folder'] = ObjectSerializer.serialize(request.folder, 'string');
    }
    let requestOptions = {
      method: 'PUT',
      qs: requestQueryParameters,
      headers: requestHeaderParams,
      uri: requestPath,
      body: ObjectSerializer.serialize(request.readerParams, 'ReaderParams'),
      json: true
    };
    await this._configuration.authentication.applyToRequest(requestOptions);
    const result = await this._client.requestAsync(requestOptions);
    return {
      response: result.response,
      body: ObjectSerializer.deserialize(result.body, 'BarcodeResponseList')
    };
  }
  /**
   *
   * @summary Generate image with multiple barcodes and put new file on server
   * @param request PutGenerateMultipleRequest
   */
  async putGenerateMultiple(request) {
    const requestPath = this._configuration.getApiBaseUrl() + '/barcode/{name}/generateMultiple'.replace('{' + 'name' + '}', String(request.name));
    let requestQueryParameters = {};
    let requestHeaderParams = Object.assign({}, this.defaultHeaders);
    // verify required parameter 'request.name' is not null or undefined
    if (request.name == null) {
      throw new Error('Required parameter request.name was null or undefined when calling putGenerateMultiple.');
    }
    // verify required parameter 'request.generatorParamsList' is not null or undefined
    if (request.generatorParamsList == null) {
      throw new Error('Required parameter request.generatorParamsList was null or undefined when calling putGenerateMultiple.');
    }
    if (request.format != null) {
      requestQueryParameters['format'] = ObjectSerializer.serialize(request.format, 'string');
    }
    if (request.folder != null) {
      requestQueryParameters['folder'] = ObjectSerializer.serialize(request.folder, 'string');
    }
    if (request.storage != null) {
      requestQueryParameters['storage'] = ObjectSerializer.serialize(request.storage, 'string');
    }
    let requestOptions = {
      method: 'PUT',
      qs: requestQueryParameters,
      headers: requestHeaderParams,
      uri: requestPath,
      body: ObjectSerializer.serialize(request.generatorParamsList, 'GeneratorParamsList'),
      json: true
    };
    await this._configuration.authentication.applyToRequest(requestOptions);
    const result = await this._client.requestAsync(requestOptions);
    return {
      response: result.response,
      body: ObjectSerializer.deserialize(result.body, 'ResultImageInfo')
    };
  }
}
class FileApi {
  constructor(configuration) {
    this.defaultHeaders = {};
    this._configuration = configuration;
    this._client = new HttpClient();
  }
  /**
   *
   * @summary Copy file
   * @param request CopyFileRequest
   */
  async copyFile(request) {
    const requestPath = this._configuration.getApiBaseUrl() + '/barcode/storage/file/copy/{srcPath}'.replace('{' + 'srcPath' + '}', String(request.srcPath));
    let requestQueryParameters = {};
    let requestHeaderParams = Object.assign({}, this.defaultHeaders);
    // verify required parameter 'request.srcPath' is not null or undefined
    if (request.srcPath == null) {
      throw new Error('Required parameter request.srcPath was null or undefined when calling copyFile.');
    }
    // verify required parameter 'request.destPath' is not null or undefined
    if (request.destPath == null) {
      throw new Error('Required parameter request.destPath was null or undefined when calling copyFile.');
    }
    if (request.destPath != null) {
      requestQueryParameters['destPath'] = ObjectSerializer.serialize(request.destPath, 'string');
    }
    if (request.srcStorageName != null) {
      requestQueryParameters['srcStorageName'] = ObjectSerializer.serialize(request.srcStorageName, 'string');
    }
    if (request.destStorageName != null) {
      requestQueryParameters['destStorageName'] = ObjectSerializer.serialize(request.destStorageName, 'string');
    }
    if (request.versionId != null) {
      requestQueryParameters['versionId'] = ObjectSerializer.serialize(request.versionId, 'string');
    }
    let requestOptions = {
      method: 'PUT',
      qs: requestQueryParameters,
      headers: requestHeaderParams,
      uri: requestPath
    };
    await this._configuration.authentication.applyToRequest(requestOptions);
    const result = await this._client.requestAsync(requestOptions);
    return result;
  }
  /**
   *
   * @summary Delete file
   * @param request DeleteFileRequest
   */
  async deleteFile(request) {
    const requestPath = this._configuration.getApiBaseUrl() + '/barcode/storage/file/{path}'.replace('{' + 'path' + '}', String(request.path));
    let requestQueryParameters = {};
    let requestHeaderParams = Object.assign({}, this.defaultHeaders);
    // verify required parameter 'request.path' is not null or undefined
    if (request.path == null) {
      throw new Error('Required parameter request.path was null or undefined when calling deleteFile.');
    }
    if (request.storageName != null) {
      requestQueryParameters['storageName'] = ObjectSerializer.serialize(request.storageName, 'string');
    }
    if (request.versionId != null) {
      requestQueryParameters['versionId'] = ObjectSerializer.serialize(request.versionId, 'string');
    }
    let requestOptions = {
      method: 'DELETE',
      qs: requestQueryParameters,
      headers: requestHeaderParams,
      uri: requestPath
    };
    await this._configuration.authentication.applyToRequest(requestOptions);
    const result = await this._client.requestAsync(requestOptions);
    return result;
  }
  /**
   *
   * @summary Download file
   * @param request DownloadFileRequest
   */
  async downloadFile(request) {
    const requestPath = this._configuration.getApiBaseUrl() + '/barcode/storage/file/{path}'.replace('{' + 'path' + '}', String(request.path));
    let requestQueryParameters = {};
    let requestHeaderParams = Object.assign({}, this.defaultHeaders);
    // verify required parameter 'request.path' is not null or undefined
    if (request.path == null) {
      throw new Error('Required parameter request.path was null or undefined when calling downloadFile.');
    }
    if (request.storageName != null) {
      requestQueryParameters['storageName'] = ObjectSerializer.serialize(request.storageName, 'string');
    }
    if (request.versionId != null) {
      requestQueryParameters['versionId'] = ObjectSerializer.serialize(request.versionId, 'string');
    }
    let requestOptions = {
      method: 'GET',
      qs: requestQueryParameters,
      headers: requestHeaderParams,
      uri: requestPath,
      encoding: null
    };
    await this._configuration.authentication.applyToRequest(requestOptions);
    const result = await this._client.requestAsync(requestOptions);
    return {
      response: result.response,
      body: ObjectSerializer.deserialize(result.body, 'Buffer')
    };
  }
  /**
   *
   * @summary Move file
   * @param request MoveFileRequest
   */
  async moveFile(request) {
    const requestPath = this._configuration.getApiBaseUrl() + '/barcode/storage/file/move/{srcPath}'.replace('{' + 'srcPath' + '}', String(request.srcPath));
    let requestQueryParameters = {};
    let requestHeaderParams = Object.assign({}, this.defaultHeaders);
    // verify required parameter 'request.srcPath' is not null or undefined
    if (request.srcPath == null) {
      throw new Error('Required parameter request.srcPath was null or undefined when calling moveFile.');
    }
    // verify required parameter 'request.destPath' is not null or undefined
    if (request.destPath == null) {
      throw new Error('Required parameter request.destPath was null or undefined when calling moveFile.');
    }
    if (request.destPath != null) {
      requestQueryParameters['destPath'] = ObjectSerializer.serialize(request.destPath, 'string');
    }
    if (request.srcStorageName != null) {
      requestQueryParameters['srcStorageName'] = ObjectSerializer.serialize(request.srcStorageName, 'string');
    }
    if (request.destStorageName != null) {
      requestQueryParameters['destStorageName'] = ObjectSerializer.serialize(request.destStorageName, 'string');
    }
    if (request.versionId != null) {
      requestQueryParameters['versionId'] = ObjectSerializer.serialize(request.versionId, 'string');
    }
    let requestOptions = {
      method: 'PUT',
      qs: requestQueryParameters,
      headers: requestHeaderParams,
      uri: requestPath
    };
    await this._configuration.authentication.applyToRequest(requestOptions);
    const result = await this._client.requestAsync(requestOptions);
    return result;
  }
  /**
   *
   * @summary Upload file
   * @param request UploadFileRequest
   */
  async uploadFile(request) {
    const requestPath = this._configuration.getApiBaseUrl() + '/barcode/storage/file/{path}'.replace('{' + 'path' + '}', String(request.path));
    let requestQueryParameters = {};
    let requestHeaderParams = Object.assign({}, this.defaultHeaders);
    // verify required parameter 'request.path' is not null or undefined
    if (request.path == null) {
      throw new Error('Required parameter request.path was null or undefined when calling uploadFile.');
    }
    // verify required parameter 'request.file' is not null or undefined
    if (request.file == null) {
      throw new Error('Required parameter request.file was null or undefined when calling uploadFile.');
    }
    if (request.storageName != null) {
      requestQueryParameters['storageName'] = ObjectSerializer.serialize(request.storageName, 'string');
    }
    let requestOptions = {
      method: 'PUT',
      qs: requestQueryParameters,
      headers: requestHeaderParams,
      uri: requestPath,
      body: request.file
    };
    await this._configuration.authentication.applyToRequest(requestOptions);
    const result = await this._client.requestAsync(requestOptions);
    return {
      response: result.response,
      body: ObjectSerializer.deserialize(result.body, 'FilesUploadResult')
    };
  }
}
class FolderApi {
  constructor(configuration) {
    this.defaultHeaders = {};
    this._configuration = configuration;
    this._client = new HttpClient();
  }
  /**
   *
   * @summary Copy folder
   * @param request CopyFolderRequest
   */
  async copyFolder(request) {
    const requestPath = this._configuration.getApiBaseUrl() + '/barcode/storage/folder/copy/{srcPath}'.replace('{' + 'srcPath' + '}', String(request.srcPath));
    let requestQueryParameters = {};
    let requestHeaderParams = Object.assign({}, this.defaultHeaders);
    // verify required parameter 'request.srcPath' is not null or undefined
    if (request.srcPath == null) {
      throw new Error('Required parameter request.srcPath was null or undefined when calling copyFolder.');
    }
    // verify required parameter 'request.destPath' is not null or undefined
    if (request.destPath == null) {
      throw new Error('Required parameter request.destPath was null or undefined when calling copyFolder.');
    }
    if (request.destPath != null) {
      requestQueryParameters['destPath'] = ObjectSerializer.serialize(request.destPath, 'string');
    }
    if (request.srcStorageName != null) {
      requestQueryParameters['srcStorageName'] = ObjectSerializer.serialize(request.srcStorageName, 'string');
    }
    if (request.destStorageName != null) {
      requestQueryParameters['destStorageName'] = ObjectSerializer.serialize(request.destStorageName, 'string');
    }
    let requestOptions = {
      method: 'PUT',
      qs: requestQueryParameters,
      headers: requestHeaderParams,
      uri: requestPath
    };
    await this._configuration.authentication.applyToRequest(requestOptions);
    const result = await this._client.requestAsync(requestOptions);
    return result;
  }
  /**
   *
   * @summary Create the folder
   * @param request CreateFolderRequest
   */
  async createFolder(request) {
    const requestPath = this._configuration.getApiBaseUrl() + '/barcode/storage/folder/{path}'.replace('{' + 'path' + '}', String(request.path));
    let requestQueryParameters = {};
    let requestHeaderParams = Object.assign({}, this.defaultHeaders);
    // verify required parameter 'request.path' is not null or undefined
    if (request.path == null) {
      throw new Error('Required parameter request.path was null or undefined when calling createFolder.');
    }
    if (request.storageName != null) {
      requestQueryParameters['storageName'] = ObjectSerializer.serialize(request.storageName, 'string');
    }
    let requestOptions = {
      method: 'PUT',
      qs: requestQueryParameters,
      headers: requestHeaderParams,
      uri: requestPath
    };
    await this._configuration.authentication.applyToRequest(requestOptions);
    const result = await this._client.requestAsync(requestOptions);
    return result;
  }
  /**
   *
   * @summary Delete folder
   * @param request DeleteFolderRequest
   */
  async deleteFolder(request) {
    const requestPath = this._configuration.getApiBaseUrl() + '/barcode/storage/folder/{path}'.replace('{' + 'path' + '}', String(request.path));
    let requestQueryParameters = {};
    let requestHeaderParams = Object.assign({}, this.defaultHeaders);
    // verify required parameter 'request.path' is not null or undefined
    if (request.path == null) {
      throw new Error('Required parameter request.path was null or undefined when calling deleteFolder.');
    }
    if (request.storageName != null) {
      requestQueryParameters['storageName'] = ObjectSerializer.serialize(request.storageName, 'string');
    }
    if (request.recursive != null) {
      requestQueryParameters['recursive'] = ObjectSerializer.serialize(request.recursive, 'boolean');
    }
    let requestOptions = {
      method: 'DELETE',
      qs: requestQueryParameters,
      headers: requestHeaderParams,
      uri: requestPath
    };
    await this._configuration.authentication.applyToRequest(requestOptions);
    const result = await this._client.requestAsync(requestOptions);
    return result;
  }
  /**
   *
   * @summary Get all files and folders within a folder
   * @param request GetFilesListRequest
   */
  async getFilesList(request) {
    const requestPath = this._configuration.getApiBaseUrl() + '/barcode/storage/folder/{path}'.replace('{' + 'path' + '}', String(request.path));
    let requestQueryParameters = {};
    let requestHeaderParams = Object.assign({}, this.defaultHeaders);
    // verify required parameter 'request.path' is not null or undefined
    if (request.path == null) {
      throw new Error('Required parameter request.path was null or undefined when calling getFilesList.');
    }
    if (request.storageName != null) {
      requestQueryParameters['storageName'] = ObjectSerializer.serialize(request.storageName, 'string');
    }
    let requestOptions = {
      method: 'GET',
      qs: requestQueryParameters,
      headers: requestHeaderParams,
      uri: requestPath
    };
    await this._configuration.authentication.applyToRequest(requestOptions);
    const result = await this._client.requestAsync(requestOptions);
    return {
      response: result.response,
      body: ObjectSerializer.deserialize(result.body, 'FilesList')
    };
  }
  /**
   *
   * @summary Move folder
   * @param request MoveFolderRequest
   */
  async moveFolder(request) {
    const requestPath = this._configuration.getApiBaseUrl() + '/barcode/storage/folder/move/{srcPath}'.replace('{' + 'srcPath' + '}', String(request.srcPath));
    let requestQueryParameters = {};
    let requestHeaderParams = Object.assign({}, this.defaultHeaders);
    // verify required parameter 'request.srcPath' is not null or undefined
    if (request.srcPath == null) {
      throw new Error('Required parameter request.srcPath was null or undefined when calling moveFolder.');
    }
    // verify required parameter 'request.destPath' is not null or undefined
    if (request.destPath == null) {
      throw new Error('Required parameter request.destPath was null or undefined when calling moveFolder.');
    }
    if (request.destPath != null) {
      requestQueryParameters['destPath'] = ObjectSerializer.serialize(request.destPath, 'string');
    }
    if (request.srcStorageName != null) {
      requestQueryParameters['srcStorageName'] = ObjectSerializer.serialize(request.srcStorageName, 'string');
    }
    if (request.destStorageName != null) {
      requestQueryParameters['destStorageName'] = ObjectSerializer.serialize(request.destStorageName, 'string');
    }
    let requestOptions = {
      method: 'PUT',
      qs: requestQueryParameters,
      headers: requestHeaderParams,
      uri: requestPath
    };
    await this._configuration.authentication.applyToRequest(requestOptions);
    const result = await this._client.requestAsync(requestOptions);
    return result;
  }
}
class StorageApi {
  constructor(configuration) {
    this.defaultHeaders = {};
    this._configuration = configuration;
    this._client = new HttpClient();
  }
  /**
   *
   * @summary Get disc usage
   * @param request GetDiscUsageRequest
   */
  async getDiscUsage(request) {
    const requestPath = this._configuration.getApiBaseUrl() + '/barcode/storage/disc';
    let requestQueryParameters = {};
    let requestHeaderParams = Object.assign({}, this.defaultHeaders);
    if (request.storageName != null) {
      requestQueryParameters['storageName'] = ObjectSerializer.serialize(request.storageName, 'string');
    }
    let requestOptions = {
      method: 'GET',
      qs: requestQueryParameters,
      headers: requestHeaderParams,
      uri: requestPath
    };
    await this._configuration.authentication.applyToRequest(requestOptions);
    const result = await this._client.requestAsync(requestOptions);
    return {
      response: result.response,
      body: ObjectSerializer.deserialize(result.body, 'DiscUsage')
    };
  }
  /**
   *
   * @summary Get file versions
   * @param request GetFileVersionsRequest
   */
  async getFileVersions(request) {
    const requestPath = this._configuration.getApiBaseUrl() + '/barcode/storage/version/{path}'.replace('{' + 'path' + '}', String(request.path));
    let requestQueryParameters = {};
    let requestHeaderParams = Object.assign({}, this.defaultHeaders);
    // verify required parameter 'request.path' is not null or undefined
    if (request.path == null) {
      throw new Error('Required parameter request.path was null or undefined when calling getFileVersions.');
    }
    if (request.storageName != null) {
      requestQueryParameters['storageName'] = ObjectSerializer.serialize(request.storageName, 'string');
    }
    let requestOptions = {
      method: 'GET',
      qs: requestQueryParameters,
      headers: requestHeaderParams,
      uri: requestPath
    };
    await this._configuration.authentication.applyToRequest(requestOptions);
    const result = await this._client.requestAsync(requestOptions);
    return {
      response: result.response,
      body: ObjectSerializer.deserialize(result.body, 'FileVersions')
    };
  }
  /**
   *
   * @summary Check if file or folder exists
   * @param request ObjectExistsRequest
   */
  async objectExists(request) {
    const requestPath = this._configuration.getApiBaseUrl() + '/barcode/storage/exist/{path}'.replace('{' + 'path' + '}', String(request.path));
    let requestQueryParameters = {};
    let requestHeaderParams = Object.assign({}, this.defaultHeaders);
    // verify required parameter 'request.path' is not null or undefined
    if (request.path == null) {
      throw new Error('Required parameter request.path was null or undefined when calling objectExists.');
    }
    if (request.storageName != null) {
      requestQueryParameters['storageName'] = ObjectSerializer.serialize(request.storageName, 'string');
    }
    if (request.versionId != null) {
      requestQueryParameters['versionId'] = ObjectSerializer.serialize(request.versionId, 'string');
    }
    let requestOptions = {
      method: 'GET',
      qs: requestQueryParameters,
      headers: requestHeaderParams,
      uri: requestPath
    };
    await this._configuration.authentication.applyToRequest(requestOptions);
    const result = await this._client.requestAsync(requestOptions);
    return {
      response: result.response,
      body: ObjectSerializer.deserialize(result.body, 'ObjectExist')
    };
  }
  /**
   *
   * @summary Check if storage exists
   * @param request StorageExistsRequest
   */
  async storageExists(request) {
    const requestPath = this._configuration.getApiBaseUrl() + '/barcode/storage/{storageName}/exist'.replace('{' + 'storageName' + '}', String(request.storageName));
    let requestQueryParameters = {};
    let requestHeaderParams = Object.assign({}, this.defaultHeaders);
    // verify required parameter 'request.storageName' is not null or undefined
    if (request.storageName == null) {
      throw new Error('Required parameter request.storageName was null or undefined when calling storageExists.');
    }
    let requestOptions = {
      method: 'GET',
      qs: requestQueryParameters,
      headers: requestHeaderParams,
      uri: requestPath
    };
    await this._configuration.authentication.applyToRequest(requestOptions);
    const result = await this._client.requestAsync(requestOptions);
    return {
      response: result.response,
      body: ObjectSerializer.deserialize(result.body, 'StorageExist')
    };
  }
}

class JWTAuth {
  constructor(configuration) {
    this._configuration = configuration;
    if (configuration.accessToken) {
      // Use saved token
      this._accessToken = configuration.accessToken;
    }
    this._client = new HttpClient();
  }
  /**
   * Apply authentication settings to header and query params.
   */
  async applyToRequest(requestOptions) {
    if (this._accessToken == null) {
      this._accessToken = await this.requestToken();
    }
    if (requestOptions && requestOptions.headers) {
      requestOptions.headers.Authorization = 'Bearer ' + this._accessToken;
    }
    return Promise.resolve();
  }
  async requestToken() {
    if (!this._configuration.clientId || !this._configuration.clientSecret) {
      throw new Error("Required 'clientId' or 'clientSecret' not specified in configuration.");
    }
    const requestOptions = {
      method: 'POST',
      uri: this._configuration.tokenUrl,
      form: {
        grant_type: 'client_credentials',
        client_id: this._configuration.clientId,
        client_secret: this._configuration.clientSecret
      }
    };
    const result = await this._client.requestAsync(requestOptions);
    const parsed = JSON.parse(result.body);
    return parsed.access_token;
  }
}

(function (ApiVersion) {
  ApiVersion["v3"] = "v3.0";
})(exports.ApiVersion || (exports.ApiVersion = {}));
class Configuration {
  constructor(clientId, clientSecret, baseUrl, accessToken, tokenUrl) {
    this.version = exports.ApiVersion.v3;
    this.clientId = clientId;
    this.clientSecret = clientSecret;
    if (baseUrl) {
      this.baseUrl = baseUrl;
    } else {
      this.baseUrl = 'https://api.aspose.cloud';
    }
    this.tokenUrl = tokenUrl != null ? tokenUrl : this.baseUrl + '/connect/token';
    if (accessToken) {
      this.accessToken = accessToken;
    } else {
      this.accessToken = '';
    }
    this.authentication = new JWTAuth(this);
  }
  /**
   * Returns api base url
   */
  getApiBaseUrl() {
    return this.baseUrl + '/' + this.version;
  }
}

exports.ApiError = ApiError;
exports.ApiErrorResponse = ApiErrorResponse;
exports.AustralianPostParams = AustralianPostParams;
exports.AztecParams = AztecParams;
exports.BarcodeApi = BarcodeApi;
exports.BarcodeResponse = BarcodeResponse;
exports.BarcodeResponseList = BarcodeResponseList;
exports.CaptionParams = CaptionParams;
exports.CodabarParams = CodabarParams;
exports.CodablockParams = CodablockParams;
exports.Code128Params = Code128Params;
exports.Code16KParams = Code16KParams;
exports.Configuration = Configuration;
exports.CopyFileRequest = CopyFileRequest;
exports.CopyFolderRequest = CopyFolderRequest;
exports.CouponParams = CouponParams;
exports.CreateFolderRequest = CreateFolderRequest;
exports.DataBarParams = DataBarParams;
exports.DataMatrixParams = DataMatrixParams;
exports.DeleteFileRequest = DeleteFileRequest;
exports.DeleteFolderRequest = DeleteFolderRequest;
exports.DiscUsage = DiscUsage;
exports.DotCodeParams = DotCodeParams;
exports.DownloadFileRequest = DownloadFileRequest;
exports.ErrorDetails = ErrorDetails;
exports.FileApi = FileApi;
exports.FileVersion = FileVersion;
exports.FileVersions = FileVersions;
exports.FilesList = FilesList;
exports.FilesUploadResult = FilesUploadResult;
exports.FolderApi = FolderApi;
exports.FontParams = FontParams;
exports.GeneratorParams = GeneratorParams;
exports.GeneratorParamsList = GeneratorParamsList;
exports.GetBarcodeGenerateRequest = GetBarcodeGenerateRequest;
exports.GetBarcodeRecognizeRequest = GetBarcodeRecognizeRequest;
exports.GetDiscUsageRequest = GetDiscUsageRequest;
exports.GetFileVersionsRequest = GetFileVersionsRequest;
exports.GetFilesListRequest = GetFilesListRequest;
exports.HttpClient = HttpClient;
exports.ITFParams = ITFParams;
exports.MaxiCodeParams = MaxiCodeParams;
exports.ModelError = ModelError;
exports.MoveFileRequest = MoveFileRequest;
exports.MoveFolderRequest = MoveFolderRequest;
exports.ObjectExist = ObjectExist;
exports.ObjectExistsRequest = ObjectExistsRequest;
exports.Padding = Padding;
exports.PatchCodeParams = PatchCodeParams;
exports.Pdf417Params = Pdf417Params;
exports.PostBarcodeRecognizeFromUrlOrContentRequest = PostBarcodeRecognizeFromUrlOrContentRequest;
exports.PostGenerateMultipleRequest = PostGenerateMultipleRequest;
exports.PostalParams = PostalParams;
exports.PutBarcodeGenerateFileRequest = PutBarcodeGenerateFileRequest;
exports.PutBarcodeRecognizeFromBodyRequest = PutBarcodeRecognizeFromBodyRequest;
exports.PutGenerateMultipleRequest = PutGenerateMultipleRequest;
exports.QrParams = QrParams;
exports.ReaderParams = ReaderParams;
exports.RegionPoint = RegionPoint;
exports.ResultImageInfo = ResultImageInfo;
exports.StorageApi = StorageApi;
exports.StorageExist = StorageExist;
exports.StorageExistsRequest = StorageExistsRequest;
exports.StorageFile = StorageFile;
exports.StructuredAppend = StructuredAppend;
exports.UploadFileRequest = UploadFileRequest;
//# sourceMappingURL=aspose-barcode-cloud-node.cjs.development.js.map
